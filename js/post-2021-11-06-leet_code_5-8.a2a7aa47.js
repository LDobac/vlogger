"use strict";(self["webpackChunkvlogger"]=self["webpackChunkvlogger"]||[]).push([[930],{1849:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---5-longest-palindromic-substring\\">LeetCode - 5. Longest Palindromic Substring</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/longest-palindromic-substring/\\">LeetCode 5. Longest Palindromic Substring</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"https://uselessetymology.files.wordpress.com/2019/10/palindrome-useless-etymology-12.png\\" alt=\\"Palindrome example\\"></p>\\n<p>이번 문제는 주어진 문자열에서 가장 긴 회문(Palindrome)을 구하는 문제입니다.</p>\\n<p>회문은 위의 예시 이미지와 같이 문자열을 뒤집어도 동일한 문자열인 경우를 말합니다.</p>\\n<p>다만, 이번 문제에서는 주어진 문자열이 회문이 아닌, 문자열 내에서 회문인 가장 긴 부분 문자열을 반환하는 문제입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>첫 번째로 시도한 방법은 Brute force, 단순히 2중 반복문을 통하여 문자열을 n...j까지 n과 j를 1씩 늘려가며 회문인지 검사하고 반환하는 방법입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n{\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n    {\\n        <span class=\\"hljs-keyword\\">auto</span> substr = std::<span class=\\"hljs-built_in\\">string_view</span>(&amp;s[i], (j - i) + <span class=\\"hljs-number\\">1</span>);\\n        <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-built_in\\">isPalindrome</span>(substr))\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (longestLength &lt; (j - i) + <span class=\\"hljs-number\\">1</span>)\\n            {\\n                longestLength = (j - i) + <span class=\\"hljs-number\\">1</span>;\\n                start = i;\\n            }\\n        }\\n    }\\n}\\n\\n<span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, longestLength);\\n...\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isPalindrome</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">const</span> std::string_view&amp; s)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">auto</span> length = s.<span class=\\"hljs-built_in\\">size</span>();\\n\\n    <span class=\\"hljs-keyword\\">for</span> (std::<span class=\\"hljs-type\\">size_t</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; length; i++)\\n    {\\n        <span class=\\"hljs-keyword\\">if</span> (s[i] != s[length - i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n    }\\n    \\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n}\\n</code></pre>\\n<p>회문을 찾을 수 있는 아주 간단한 방법입니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/5/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>하지만 위 코드를 제출하니 Time Limite Exeeded, 시간 초과가 발생하였습니다.</p>\\n<p>위 코드는 i..j까지 반복문을 순회할 때의 시간 복잡도는 O(n^2)이며, 회문을 검사하는 코드의 시간 복잡도는 O(n)입니다. 즉 최종적으로 시간 복잡도가 O(n^3)의 코드이기에 매우 긴 문자열을 검사할 때 시간 초과가 발생하게 되었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string_view&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">longestPalindrome</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span> || s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> start = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n        {\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n            {\\n                <span class=\\"hljs-keyword\\">auto</span> substr = std::<span class=\\"hljs-built_in\\">string_view</span>(&amp;s[i], (j - i) + <span class=\\"hljs-number\\">1</span>);\\n                <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-built_in\\">isPalindrome</span>(substr))\\n                {\\n                    <span class=\\"hljs-keyword\\">if</span> (longestLength &lt; (j - i) + <span class=\\"hljs-number\\">1</span>)\\n                    {\\n                        longestLength = (j - i) + <span class=\\"hljs-number\\">1</span>;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, longestLength);\\n    }\\n\\n<span class=\\"hljs-keyword\\">private</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isPalindrome</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">const</span> std::string_view&amp; s)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">auto</span> length = s.<span class=\\"hljs-built_in\\">size</span>();\\n\\n        <span class=\\"hljs-keyword\\">for</span> (std::<span class=\\"hljs-type\\">size_t</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; length; i++)\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (s[i] != s[length - i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2---dynamic-programming\\">Solution 2 - Dynamic programming</h3>\\n<p>두 번째 방법은 동적 프로그래밍(Dynamic programming)을 이용한 풀이입니다.</p>\\n<p>회문의 특성을 생각해볼때 만약 <em>abcba</em>라는 회문 문자열이 존재한다면 해당 문자열의 부분 문자열 <em>bcb</em>또한 회문이며, <em>bcb</em>의 부분 문자열 <em>c</em>또한 회문임을 알 수 있습니다.</p>\\n<p>두 번째로 문자가 하나인 경우 <em>c</em>와 같은 경우는 무조건 회문입니다. 그리고 만약 <em>c</em>의 앞뒤로 문자가 하나씩 추가 될 때 두 문자가 같다면, <em>bcb</em>가 된다면 이 또한 회문이 됩니다.</p>\\n<p>이러한 특성과 동적 프로그래밍을 이미 회문을 검사한 문자열을 또 검사하지 않고 새로운 회문 문자열을 찾을 수 있습니다.</p>\\n<p>먼저 규칙을 정의합니다.</p>\\n<ol>\\n<li>S(i, j) : 문자열 S에 대해서 i번째부터 j번째까지의 부분 문자열</li>\\n<li>S(i, i) = 회문</li>\\n<li>S(i, i+1) = S_i == S_i+1일 경우 회문</li>\\n<li>S(i, j) = S(i+1, j-1) &amp;&amp; S_i == S_j 일 경우 회문</li>\\n</ol>\\n<p>2번 규칙의 경우 S(i, i)는 S문자열의 i번째부터 i번째까지 부분 문자열, 즉 하나의 문자에 대해서 회문임을 확인하기에 무조건 회문입니다.</p>\\n<p>3번 규칙은 S(i, i+1)는 선택한 문자와 인접한 문자가 같다면 회문임을 나타냅니다. <strong>&quot;bb&quot;</strong> 와 같은 경우를 나타냅니다.</p>\\n<p>4번 규칙은 위에서 말했듯이 부분 문자열이 회문이고, 앞 뒤로 추가되는 문자열이 같다면 새로 추가되는 문자열도 회문임을 나타냅니다.</p>\\n<pre><code class=\\"language-c++\\">std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">bool</span>&gt;&gt; <span class=\\"hljs-built_in\\">dp</span>(s.<span class=\\"hljs-built_in\\">size</span>(), std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">bool</span>&gt;(s.<span class=\\"hljs-built_in\\">size</span>(), <span class=\\"hljs-literal\\">false</span>));\\n</code></pre>\\n<p><code>std::vector</code> STL 컨테이너를 이용해 2차원 동적 배열을 선언합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span> ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n{\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt;= j ; i++)\\n    {\\n        <span class=\\"hljs-type\\">bool</span> same = s[i] == s[j];\\n\\n        <span class=\\"hljs-comment\\">// 문자열 길이가 2이상일때는 dp[i + 1][j - 1]즉, substr이 회문이여야 함</span>\\n        <span class=\\"hljs-comment\\">// 문자열 길이가 2일경우(i, i+1) 두 문자가 같아야 회문</span>\\n        <span class=\\"hljs-comment\\">// 문자열 길이가 1일경우 무조건 회문</span>\\n        dp[i][j] = j - i &gt; <span class=\\"hljs-number\\">2</span> ? (dp[i + <span class=\\"hljs-number\\">1</span>][j - <span class=\\"hljs-number\\">1</span>] &amp;&amp; same) : same;\\n        \\n        <span class=\\"hljs-keyword\\">if</span> ((longestLen &lt; (j - i + <span class=\\"hljs-number\\">1</span>)) &amp;&amp; dp[i][j])\\n        {\\n            longestLen = j - i + <span class=\\"hljs-number\\">1</span>;\\n            start = i;\\n        }\\n    }\\n}\\n</code></pre>\\n<p>i와 j는 각각 S(i, j)로 부분문자열 시작 index인 i부터 j까지를 나타냅니다. </p>\\n<p>j - i가 2보다 작으면 규칙 2와 규칙 3을 적용할 수 있기에 단순히 S_i와 S_j를 비교한 결과가 저장됩니다.</p>\\n<p>j - i가 2보다 큰 경우는 문자열의 길이가 최소 3이상이므로 부분 문자열이 회문인지 검사하고 새로 추가된 문자 둘이 같은지 확인해야 합니다. S(i, j)의 부분 문자열 S(i+1, j-1)은 이미 계산이 되어 배열에 삽입되어 있을태니 추가로 계산할 필요 없이 값을 조회만 하면 됩니다.</p>\\n<p>마지막으로 지금 확인한 문자열이 회문이고 가장 길다면 해당 문자열의 인덱스를 저장합니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/5/result_2.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>1번 해결 방법의 경우 O(n^3)이기 때문에 시간 초과가 발생했지만, 이번 방법의 경우 O(n^2)의 시간 복잡도이기 때문에 시간 초과가 발생하지 않았습니다.</p>\\n<p>784ms 시간이 소요되었으며 다른 C++코드 제출자에 비해서 10% 정도의 성능밖에 보이지 않았습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string_view&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">longestPalindrome</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span> || s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLen = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> start = <span class=\\"hljs-number\\">0</span>;\\n\\n        std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">bool</span>&gt;&gt; <span class=\\"hljs-built_in\\">dp</span>(s.<span class=\\"hljs-built_in\\">size</span>(), std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">bool</span>&gt;(s.<span class=\\"hljs-built_in\\">size</span>(), <span class=\\"hljs-literal\\">false</span>));\\n\\n        <span class=\\"hljs-comment\\">// 열 기반으로 탐색</span>\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span> ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n        {\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt;= j ; i++)\\n            {\\n                <span class=\\"hljs-type\\">bool</span> same = s[i] == s[j];\\n\\n                <span class=\\"hljs-comment\\">// 문자열 길이가 2이상일때는 dp[i + 1][j - 1]즉, substr이 회문이여야 함</span>\\n                <span class=\\"hljs-comment\\">// 문자열 길이가 2일경우(i, i+1) 두 문자가 같아야 회문</span>\\n                <span class=\\"hljs-comment\\">// 문자열 길이가 1일경우 무조건 회문</span>\\n                dp[i][j] = j - i &gt; <span class=\\"hljs-number\\">2</span> ? (dp[i + <span class=\\"hljs-number\\">1</span>][j - <span class=\\"hljs-number\\">1</span>] &amp;&amp; same) : same;\\n                \\n                <span class=\\"hljs-keyword\\">if</span> ((longestLen &lt; (j - i + <span class=\\"hljs-number\\">1</span>)) &amp;&amp; dp[i][j])\\n                {\\n                    longestLen = j - i + <span class=\\"hljs-number\\">1</span>;\\n                    start = i;\\n                }\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, longestLen);\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-3---expand-around-center\\">Solution 3 - Expand around center</h3>\\n<p>회문을 검사하기 위해서는 문자열을 시작과 끝을 정해서 회문을 검사하는 방법도 있지만, 문자열의 가운데부터 좌우로 확장하면서 회문임을 검사하는 방법도 있습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n{\\n    <span class=\\"hljs-type\\">int</span> len1 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i);\\n    <span class=\\"hljs-type\\">int</span> len2 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i + <span class=\\"hljs-number\\">1</span>);\\n    <span class=\\"hljs-type\\">int</span> len = std::<span class=\\"hljs-built_in\\">max</span>(len1, len2);\\n\\n    <span class=\\"hljs-keyword\\">if</span> (len &gt; end - start)\\n    {\\n        start = i - (len - <span class=\\"hljs-number\\">1</span>) / <span class=\\"hljs-number\\">2</span>;\\n        end = i + len / <span class=\\"hljs-number\\">2</span>;\\n    }\\n}\\n</code></pre>\\n<p><code>expandAroundCenter</code> 함수는 i를 기준으로 좌우로 확장하며 회문인지 검사하는 함수입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">expandAroundCenter</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">const</span> std::string&amp; s, <span class=\\"hljs-type\\">int</span> left, <span class=\\"hljs-type\\">int</span> right)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">while</span> ( left &gt;= <span class=\\"hljs-number\\">0</span> &amp;&amp; right &lt; s.<span class=\\"hljs-built_in\\">size</span>() &amp;&amp; s[left] == s[right])\\n    {\\n        left--;\\n        right++;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> right - left - <span class=\\"hljs-number\\">1</span>;\\n}\\n</code></pre>\\n<p><code>expandAroundCenter</code> 함수를 i와 i+1에 대해서 호출하는 이유는 문자열이 짝수인경우 회문의 중앙 문자가 2개가 존재하기 때문에 두 경우 중 긴 문자열을 선택합니다.</p>\\n<h4 id=\\"제출-결과-2\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/5/result_3.png\\" alt=\\"Solution 3 result\\"></p>\\n<p>이번 방법의 시간 복잡도는 O(n^2)이며 동적 프로그래밍과 동일합니다. 다만 공간 복잡도가 동적 프로그래밍은 O(n^2)이지만, 이번 방법의 공간 복잡도는 O(1)이기때문에 동적 프로그래밍 방법과 비교하면 메모리 사용량에서 많은 차이가 발생함을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;algorithm&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">longestPalindrome</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span> || s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n\\n        <span class=\\"hljs-type\\">int</span> start = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> end = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n        {\\n            <span class=\\"hljs-type\\">int</span> len1 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i);\\n            <span class=\\"hljs-type\\">int</span> len2 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i + <span class=\\"hljs-number\\">1</span>);\\n            <span class=\\"hljs-type\\">int</span> len = std::<span class=\\"hljs-built_in\\">max</span>(len1, len2);\\n\\n            <span class=\\"hljs-keyword\\">if</span> (len &gt; end - start)\\n            {\\n                start = i - (len - <span class=\\"hljs-number\\">1</span>) / <span class=\\"hljs-number\\">2</span>;\\n                end = i + len / <span class=\\"hljs-number\\">2</span>;\\n            }\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, (end - start) + <span class=\\"hljs-number\\">1</span>);\\n    }\\n<span class=\\"hljs-keyword\\">private</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">expandAroundCenter</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">const</span> std::string&amp; s, <span class=\\"hljs-type\\">int</span> left, <span class=\\"hljs-type\\">int</span> right)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">while</span> ( left &gt;= <span class=\\"hljs-number\\">0</span> &amp;&amp; right &lt; s.<span class=\\"hljs-built_in\\">size</span>() &amp;&amp; s[left] == s[right])\\n        {\\n            left--;\\n            right++;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> right - left - <span class=\\"hljs-number\\">1</span>;\\n    }\\n};\\n</code></pre>\\n</details>"}')}}]);