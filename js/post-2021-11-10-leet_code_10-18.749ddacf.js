"use strict";(self["webpackChunkvlogger"]=self["webpackChunkvlogger"]||[]).push([[645],{5872:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---10-regular-expression-matching\\">LeetCode - 10. Regular Expression Matching</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/regular-expression-matching/\\">LeetCode 10. Regular Expression Matching</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"https://resources.jetbrains.com/help/img/idea/2021.2/rm_tips_check_reg_exp.png\\" alt=\\"Regular expression example\\"></p>\\n<p>정규 표현식은 주어진 문자열에 대해서 패턴 문자열(정규 표현식)이 주어지면 해당 패턴을 갖는 문자열을 표현하는 방법입니다.</p>\\n<p>이번 문제에서는 Any character를 나타내는 <code>&quot;.&quot;</code> 과 0 또는 하나 이상의 문자 집합을 나타내는 <code>&quot;*&quot;</code> 패턴 문자를 구현하는 문제입니다.</p>\\n<p>난이도는 <code>HARD</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution---dynamic-programming\\">Solution - Dynamic programming</h3>\\n<p>본 문제를 풀기 위해서 동적 프로그래밍 방법을 사용하였습니다.</p>\\n<p>패턴을 찾기 위해서 문자열과 패턴 문자열을 모두 순회하면서 패턴을 찾아야 합니다.</p>\\n<p>여기서 한가지 특성은 만약 패턴 &quot;a*&quot;가 주어졌을 때 부분 패턴 문자열 &quot;a&quot;가 문자열에 매칭될 경우에 참이되며 추가적인 &quot;a&quot;를 찾을 수도 있고, 찾기 못하더라도 참이 되게때문에 여러 분기가 발생하게 됩니다.</p>\\n<p>동적 프로그래밍 방법을 이용해 부분 패턴 문자열을 순회하면서 참인 경우를 따로 저장하여 나중에 똑같은 부분 패턴을 조회할 때 똑같은 검사를 수행하지 않고 저장한 값을 반환하여 성능 향상을 노릴 수 있습니다.</p>\\n<pre><code class=\\"language-c++\\">std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">char</span>&gt;&gt; dp;\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> i, <span class=\\"hljs-type\\">int</span> j, <span class=\\"hljs-type\\">const</span> std::string&amp; s ,<span class=\\"hljs-type\\">const</span> std::string&amp; p)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (dp[i][j] != <span class=\\"hljs-number\\">-1</span>) <span class=\\"hljs-keyword\\">return</span> dp[i][j];\\n\\n    ...\\n\\n    <span class=\\"hljs-keyword\\">return</span> match;\\n}\\n</code></pre>\\n<p>먼저 2차원 배열을 선언합니다. 이 배열이 이전에 계산한 결과를 저장할 것입니다. boolean이 아닌 char 타입으로 한 이유는 아직 i, j 번째를 순회하지 않았을 경우를 따로 나타내기 위해서 모든 값을 -1으로 초기화 하였습니다.</p>\\n<p><code>isMatch</code> 함수는 i, j, 문자열, 패턴 문자열이 주어지는 함수입니다. i는 s의 부분 문자열의 시작 인덱스, j는 부분 패턴 문자열의 시작 인덱스를 나타냅니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">bool</span> firstMatch = (i &lt; s.<span class=\\"hljs-built_in\\">length</span>()) &amp;&amp; (p[j] == s[i] || p[j] == <span class=\\"hljs-string\\">&#x27;.&#x27;</span>);\\n\\n<span class=\\"hljs-comment\\">// if Kleene star, character matches zero or more</span>\\n<span class=\\"hljs-keyword\\">if</span> (j + <span class=\\"hljs-number\\">1</span> &lt; p.<span class=\\"hljs-built_in\\">length</span>() &amp;&amp; p[j + <span class=\\"hljs-number\\">1</span>] == <span class=\\"hljs-string\\">&#x27;*&#x27;</span>)\\n{\\n            <span class=\\"hljs-comment\\">// If zero match, skip Kleene star</span>\\n    match = <span class=\\"hljs-built_in\\">isMatch</span>(i, j + <span class=\\"hljs-number\\">2</span>, s, p) || \\n            <span class=\\"hljs-comment\\">// If non-zero matches, keep finding more matches character</span>\\n            (firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j, s, p));\\n}\\n<span class=\\"hljs-keyword\\">else</span>\\n{\\n    <span class=\\"hljs-comment\\">// Finding next matches character</span>\\n    match = firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j + <span class=\\"hljs-number\\">1</span>, s, p);\\n}\\n</code></pre>\\n<p>매칭을 수행하는 부분만 따로 빼서 자세히 확인해보겠습니다. 먼저 현재 패턴 문자와 입력 문자가 같은지 확인합니다. 만약 패턴 문자가 <code>&#39;.&#39;</code> 이라면 모든 문자와 매칭되니 <code>true</code>가 될 것입니다.</p>\\n<p>만약 0또는 1개 이상의 문자 집합을 매칭하는 <code>&#39;*&#39;</code> 문자는 &quot;a*&quot;와 같이 다른 문자와 함께 붙어서 나오기 때문에 해당 부분에 대해서 확인하고 예외 처리를 진행합니다.</p>\\n<p><code>&#39;*&#39;</code> 문자는 0개 또는 1개 이상의 문자열과 매칭되기 때문에 첫 번째로 0개가 매칭 되었을 경우 <code>isMatch(i, j + 2, s, p)</code>에 대해서 확인합니다. <code>j+2</code>의 의미는 패턴 문자열의 시작 인덱스를 2만큼 증가시키니 <code>&#39;*&#39;</code> 문자 이후의 패턴들을 검사합니다.</p>\\n<p>두 번째로 하나의 문자가 매치되었을 경우(firstMatch) 현재 문자 이후의 문자가 계속 연속적으로 매칭되는지 확인합니다 <code>(firstMatch &amp;&amp; isMatch(i+1, j, s, p))</code></p>\\n<p>만약 <code>&#39;*&#39;</code> 문자가 아니고 문자 매칭이라면 i + 1, j + 1에 대해서 계속 매치를 시도합니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/10/result.png\\" alt=\\"Solution 1 result\\"></p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(std::string s, std::string p)</span> \\n    </span>{\\n        std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">char</span>&gt;&gt; <span class=\\"hljs-built_in\\">tmp</span>(s.<span class=\\"hljs-built_in\\">size</span>() + <span class=\\"hljs-number\\">1</span>, std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">char</span>&gt;(p.<span class=\\"hljs-built_in\\">size</span>() + <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">-1</span>));\\n        dp.<span class=\\"hljs-built_in\\">swap</span>(tmp);\\n\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">isMatch</span>(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>, s, p);\\n    }\\n\\n<span class=\\"hljs-keyword\\">private</span>:\\n    std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">char</span>&gt;&gt; dp;\\n\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> i, <span class=\\"hljs-type\\">int</span> j, <span class=\\"hljs-type\\">const</span> std::string&amp; s ,<span class=\\"hljs-type\\">const</span> std::string&amp; p)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (dp[i][j] != <span class=\\"hljs-number\\">-1</span>) <span class=\\"hljs-keyword\\">return</span> dp[i][j];\\n\\n        <span class=\\"hljs-type\\">char</span> match = <span class=\\"hljs-number\\">-1</span>;\\n\\n        <span class=\\"hljs-comment\\">// If no more patterns</span>\\n        <span class=\\"hljs-keyword\\">if</span> (j == p.<span class=\\"hljs-built_in\\">length</span>())\\n        {\\n            <span class=\\"hljs-comment\\">// True when no more string, If string does not empty, False</span>\\n            match = (i == s.<span class=\\"hljs-built_in\\">length</span>());\\n        }\\n        <span class=\\"hljs-keyword\\">else</span> \\n        {\\n            <span class=\\"hljs-type\\">bool</span> firstMatch = (i &lt; s.<span class=\\"hljs-built_in\\">length</span>()) &amp;&amp; (p[j] == s[i] || p[j] == <span class=\\"hljs-string\\">&#x27;.&#x27;</span>);\\n\\n            <span class=\\"hljs-comment\\">// if Kleene star, character matches zero or more</span>\\n            <span class=\\"hljs-keyword\\">if</span> (j + <span class=\\"hljs-number\\">1</span> &lt; p.<span class=\\"hljs-built_in\\">length</span>() &amp;&amp; p[j + <span class=\\"hljs-number\\">1</span>] == <span class=\\"hljs-string\\">&#x27;*&#x27;</span>)\\n            {\\n                        <span class=\\"hljs-comment\\">// If zero match, skip Kleene star</span>\\n                match = <span class=\\"hljs-built_in\\">isMatch</span>(i, j + <span class=\\"hljs-number\\">2</span>, s, p) || \\n                        <span class=\\"hljs-comment\\">// If non-zero matches, keep finding more matches character</span>\\n                        (firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j, s, p));\\n            }\\n            <span class=\\"hljs-comment\\">// </span>\\n            <span class=\\"hljs-keyword\\">else</span>\\n            {\\n                <span class=\\"hljs-comment\\">// Finding next matches character</span>\\n                match = firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j + <span class=\\"hljs-number\\">1</span>, s, p);\\n            }\\n        }\\n\\n        dp[i][j] = match;\\n\\n        <span class=\\"hljs-keyword\\">return</span> match;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')}}]);