"use strict";(self["webpackChunkvlogger"]=self["webpackChunkvlogger"]||[]).push([[427],{2962:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---19-remove-nth-node-from-end-of-list\\">LeetCode - 19. Remove Nth Node From End of List</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\\">LeetCode - 19. Remove Nth Node From End of List</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"/assets/images/leet_code/19/example_1.jpg\\" alt=\\"example 1\\"></p>\\n<p>단방향 연결 리스트와 삭제할 인덱스가 입력으로 주어집니다.</p>\\n<p>삭제할 인덱스는 연결 리스트의 끝에서 n번째의 노드를 삭제합니다.</p>\\n<p>위 사진의 예시는 [1, 2, 3, 4, 5]의 연결 리스트가 주어지고, n = 2가 주어졌기 때문에 리스트의 끝에서 2번째인 <code>[4]</code> 노드가 삭제됩니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<p><a href=\\"https://github.com/LDobac/leetcode/tree/master/19.%20Remove%20Nth%20Node%20From%20End%20of%20List\\">My Solutions(Github)</a></p>\\n<h3 id=\\"solution\\">Solution</h3>\\n<p>양방향 연결 리스트가 아니고, 단방향이기 때문에 next 포인터 밖에 없습니다.</p>\\n<p>때문에 리스트의 끝에서 n번쨰 노드를 삭제하기 위해서는 2번의 리스트 순회가 필요합니다. </p>\\n<p>첫번째 순회는 연결 리스트의 길이를 알아내는 것입니다. 연결 리스트의 길이를 알아야 연결 리스트의 끝에서 n 번째 노드를 알아낼 수 있습니다.</p>\\n<pre><code class=\\"language-c++\\">ListNode* cur = head;\\n<span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n<span class=\\"hljs-keyword\\">while</span> (cur)\\n{\\n    length++;\\n\\n    cur = cur-&gt;next;\\n}\\n</code></pre>\\n<p>그리고 두 번째 순회는 삭제할 노드를 찾기 위해 순회해야 합니다. 연결 리스트의 길이는 알아냈으니 뒤에서 n번째 노드를 찾기 위해서는 length - n번 순회 하면 됩니다.</p>\\n<pre><code class=\\"language-c++\\">ListNode* prevOfTarget = <span class=\\"hljs-literal\\">nullptr</span>;\\nListNode* target = head;\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = length - n; i &gt; <span class=\\"hljs-number\\">0</span>; i--)\\n{\\n    prevOfTarget = target;\\n    target = target-&gt;next;\\n}\\n</code></pre>\\n<p>단방향 연결 리스트이니 삭제할 노드와 해당 이전 노드를 따로 변수로 저장합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> (prevOfTarget == <span class=\\"hljs-literal\\">nullptr</span>)\\n{\\n    head = target-&gt;next;\\n}\\n<span class=\\"hljs-keyword\\">else</span>\\n{\\n    prevOfTarget-&gt;next = target-&gt;next;\\n}\\n</code></pre>\\n<p>만약 이전 노드가 <code>nullptr</code>이라면 head노드를 삭제하는게 되니, head노드를 삭제할 노드의 다음 노드를 가리키게 합니다.</p>\\n<p>아니라면 일반 연결 리스트 삭제 과정을 수행합니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/19/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행 속도는 4ms가 나왔습니다. 아마도 실행시마다 조금씩 달라지는 leetcode의 실행속도 때문에 4ms가 나온 듯 합니다. 아마 재시도를 몇 번 더 하면 0ms의 실행 속도가 나올수도 있을 듯 합니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">ListNode* <span class=\\"hljs-title\\">removeNthFromEnd</span><span class=\\"hljs-params\\">(ListNode* head, <span class=\\"hljs-type\\">int</span> n)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (!head-&gt;next &amp;&amp; n &gt; <span class=\\"hljs-number\\">0</span>)\\n        {\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">nullptr</span>;\\n        }\\n\\n        ListNode* cur = head;\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">while</span> (cur)\\n        {\\n            length++;\\n\\n            cur = cur-&gt;next;\\n        }\\n        \\n        ListNode* prevOfTarget = <span class=\\"hljs-literal\\">nullptr</span>;\\n        ListNode* target = head;\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = length - n; i &gt; <span class=\\"hljs-number\\">0</span>; i--)\\n        {\\n            prevOfTarget = target;\\n            target = target-&gt;next;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">if</span> (prevOfTarget == <span class=\\"hljs-literal\\">nullptr</span>)\\n        {\\n            head = target-&gt;next;\\n        }\\n        <span class=\\"hljs-keyword\\">else</span>\\n        {\\n            prevOfTarget-&gt;next = target-&gt;next;\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> head;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')}}]);