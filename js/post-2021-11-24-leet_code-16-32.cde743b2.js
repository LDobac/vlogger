"use strict";(self["webpackChunkvlogger"]=self["webpackChunkvlogger"]||[]).push([[316],{9906:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---16-3sum-closest\\">LeetCode - 16. 3Sum Closest</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/3sum-closest/\\">LeetCode - 16. 3Sum Closest</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>숫자 배열과 target 숫자가 주어지면 숫자 배열에서 세 숫자를 더했을 때 target 숫자와 가장 가까운 세 숫자의 덧셈을 반환하면 되는 문제입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<p><a href=\\"https://github.com/LDobac/leetcode/tree/master/16.%203Sum%20Closest\\">My Solutions(Github)</a></p>\\n<h3 id=\\"solution\\">Solution</h3>\\n<p>문제 <a href=\\"https://jaehee.dev/#/post/15\\">LeetCode - 15. 3Sum</a>과 상당히 유사한 문제입니다. 유일하게 다른점은 모든 가짓수를 반환하는 것이 아닌 덧셈의 결과를 반환한다는 점과, target에 해당하는 숫자가 없더라도 가장 가까운 덧셈을 반환해야 합니다.</p>\\n<p>15번 문제와 상당히 유사하므로 적절한 세 숫자를 찾이 위해 순회를 하는 과정은 제외하고, target 숫자와 가장 가까운 숫자를 구하는 방법 위주로 설명하겠습니다.</p>\\n<p>간단히 생각해보도록 하겠습니다. target 숫자와 가장 가까운 세 숫자의 덧셈을 찾아내면 되는 문제입니다. 이를 그래프상에 놓는다고 생각한다면 target 숫자와 가장 <em>거리</em>가 가까운 덧셈의 결과를 찾으면 됩니다.</p>\\n<p><em>거리</em>를 구하는 방법은 수학적으로 다양하게 있지만, 여기서는 가장 기본적인 <em>절대값</em>을 이용해 target 숫자와의 거리를 계산하겠습니다.</p>\\n<p><em>절대값</em>은 일반적으로 수직선상의 특정 점에서부터 얼마나 떨어졌는가를 계산할 수 있습니다. 이를 이용해 target 숫자와의 거리를 계산할 수 있습니다. 그리고 모든 수에 대해서 순회를 하면서 거리가 0이 되거나 가장 거리가 가까운 덧셈을 반환하면 됩니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> shortestPath = INT_MAX;\\n</code></pre>\\n<p>지금까지 계산한 거리 중 가장 target 숫자와 가까운 거리를 저장하는 변수인 <code>shortestPath</code>를 선언하겠습니다. 입력된 숫자들은 <code>int</code> 배열이므로, int형 변수로 선언하며, 초기 값은 int형 변수의 최대값으로 초기화하겠습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> sum = nums[i] + nums[left] + nums[right];\\n<span class=\\"hljs-type\\">int</span> path = <span class=\\"hljs-built_in\\">abs</span>(target - sum);\\n\\n<span class=\\"hljs-keyword\\">if</span> (sum &gt; target) right--;\\n<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (sum &lt; target) left++;\\n\\n<span class=\\"hljs-keyword\\">if</span> (path == <span class=\\"hljs-number\\">0</span>)\\n{\\n    <span class=\\"hljs-keyword\\">return</span> sum;\\n}\\n<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (path &lt; shortestPath)\\n{\\n    shortestPath = path;\\n    result = sum;\\n}\\n</code></pre>\\n<p>반복문 내부입니다. 순회 과정에 대한 정확한 설명은 <a href=\\"https://jaehee.dev/#/post/15\\">문제 15</a>를 참고하시면 좋습니다.</p>\\n<p>현재 선택된 세 숫자를 더해 target 숫자와의 차에 대해서 절대값을 계산합니다.</p>\\n<p>만약 절대값(path 변수)이 0이라면 target 숫자와 동일한 덧셈이 존재한다는 의미으로 바로 함수를 반환합니다.</p>\\n<p>아니라면 현재 계산된 거리가 가장 target과 가까운 거리인지 확인하고 해당하는 변수들을 업데이트합니다. 그리고 모든 순회가 종료되고 가장 거리가 가까웠던 합계를 반환하면 됩니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/16/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행 시간은 8ms가 나왔으며, 다른 C++ 제출자에 비해 80% 가량의 성능을 보임을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">threeSumClosest</span><span class=\\"hljs-params\\">(vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums, <span class=\\"hljs-type\\">int</span> target)</span> \\n    </span>{\\n        <span class=\\"hljs-type\\">int</span> result;\\n        <span class=\\"hljs-type\\">int</span> shortestPath = INT_MAX;\\n\\n        <span class=\\"hljs-built_in\\">sort</span>(nums.<span class=\\"hljs-built_in\\">begin</span>(), nums.<span class=\\"hljs-built_in\\">end</span>());\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (i &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">continue</span>;\\n\\n            <span class=\\"hljs-type\\">int</span> left = i + <span class=\\"hljs-number\\">1</span>;\\n            <span class=\\"hljs-type\\">int</span> right = nums.<span class=\\"hljs-built_in\\">size</span>() - <span class=\\"hljs-number\\">1</span>;\\n\\n            <span class=\\"hljs-keyword\\">while</span> (left &lt; right)\\n            {\\n                <span class=\\"hljs-type\\">int</span> sum = nums[i] + nums[left] + nums[right];\\n                <span class=\\"hljs-type\\">int</span> path = <span class=\\"hljs-built_in\\">abs</span>(target - sum);\\n\\n                <span class=\\"hljs-keyword\\">if</span> (sum &gt; target) right--;\\n                <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (sum &lt; target) left++;\\n\\n                <span class=\\"hljs-keyword\\">if</span> (path == <span class=\\"hljs-number\\">0</span>)\\n                {\\n                    <span class=\\"hljs-keyword\\">return</span> sum;\\n                }\\n                <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (path &lt; shortestPath)\\n                {\\n                    shortestPath = path;\\n                    result = sum;\\n                }\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')}}]);