"use strict";(self["webpackChunkvlogger"]=self["webpackChunkvlogger"]||[]).push([[15],{9650:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---14-longest-common-prefix\\">LeetCode - 14. Longest Common Prefix</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/longest-common-prefix/\\">LeetCode 14. Longest Common Prefix</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>문자열 리스트가 주어질 때 가장 긴 접두사를 찾으면 됩니다.</p>\\n<p>예를 들어 <code>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code>가 주어졌다면 모든 문자열에 <code>fl</code>이라는 접두사가 붙었으니 해당 문자열을 반환하면 됩니다.</p>\\n<p>반대로 <code>[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</code>라는 입력이 주어졌다면 모든 문자열에 공통이 되는 접두사가 없으므로 빈 문자열을 반환하면 됩니다.</p>\\n<p>난이도는 <code>EASY</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<p><a href=\\"https://github.com/LDobac/leetcode/tree/master/14.%20Longest%20Common%20Prefix\\">My Solutions(Github)</a></p>\\n<h3 id=\\"solution\\">Solution</h3>\\n<p>첫 번째로 고려해야 하는 조건은 접두사는 모든 문자열의 길이보다 작거나 같아야합니다. 다른 문자열의 길이보다 접두사가 더 길면 접두사가 될 수 없기때문입니다.</p>\\n<p>두 번째로 한 문자열의 전체가 다른 문자열의 접두사가 될 수로 있습니다. 예를 들어 <code>flow</code>라는 문자열은 <code>flower</code>의 접두사가 될 수 있겠죠.</p>\\n<pre><code class=\\"language-c++\\">string&amp; prefix = strs[<span class=\\"hljs-number\\">0</span>];\\n\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">1</span>; i &lt; length ; i++)\\n{\\n    ...\\n}\\n</code></pre>\\n<p>첫 번째 문자열을 선택하여 순회를 시작합니다. 다른 문자열을 선택해도 충분히 문제가 없을 듯 합니다. 하지만, 코드의 가독성을 위해 첫 번째나 마지막 문자열을 선택하는 것이 가장 좋은 선택지가 될 것 같네요.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> (prefix.<span class=\\"hljs-built_in\\">size</span>() &gt; strs[i].<span class=\\"hljs-built_in\\">size</span>())\\n{\\n    prefix = prefix.<span class=\\"hljs-built_in\\">substr</span>(<span class=\\"hljs-number\\">0</span>, strs[i].<span class=\\"hljs-built_in\\">size</span>());\\n}\\n</code></pre>\\n<p>문자열을 순회하던 중 현재 선택된 접두사가 문자열보다 더 길다면 문자열의 길이로 축소합니다. 그리고 한 문자열이 다른 문자열의 접두사가 될 수 있으므로 더 줄일 필요는 없을 것 같습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span>; j &lt; prefix.<span class=\\"hljs-built_in\\">size</span>(); j++)\\n{\\n    <span class=\\"hljs-keyword\\">if</span> (prefix[j] != strs[i][j])\\n    {\\n        prefix = prefix.<span class=\\"hljs-built_in\\">substr</span>(<span class=\\"hljs-number\\">0</span>, j);\\n    }\\n}\\n</code></pre>\\n<p>이제 접두사와 문자열을 비교합니다. 가장 긴 공통된 접두사를 찾는 문제이므로 접두사와 다른 문자를 발견한다면 접두사의 길이를 공통된 부분까지만 축소합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> (prefix.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">break</span>;\\n</code></pre>\\n<p>문자열을 계속 순회하던 중 접두사의 길이가 0이되면 순회를 탈출하는 것이 소소한 최적화에 도움이 될 것 같습니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/14/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>문제 자체가 시워서 첫 시도만에 100%의 성능을 보이는 코드를 작성할 수 있었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">string <span class=\\"hljs-title\\">longestCommonPrefix</span><span class=\\"hljs-params\\">(vector&lt;string&gt;&amp; strs)</span> \\n    </span>{\\n        <span class=\\"hljs-type\\">int</span> length = strs.<span class=\\"hljs-built_in\\">size</span>();\\n\\n        <span class=\\"hljs-keyword\\">if</span> (length == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-string\\">&quot;&quot;</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (length == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> strs[<span class=\\"hljs-number\\">0</span>];\\n\\n        string&amp; prefix = strs[<span class=\\"hljs-number\\">0</span>];\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">1</span>; i &lt; length ; i++)\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (prefix.<span class=\\"hljs-built_in\\">size</span>() &gt; strs[i].<span class=\\"hljs-built_in\\">size</span>())\\n            {\\n                prefix = prefix.<span class=\\"hljs-built_in\\">substr</span>(<span class=\\"hljs-number\\">0</span>, strs[i].<span class=\\"hljs-built_in\\">size</span>());\\n            }\\n\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span>; j &lt; prefix.<span class=\\"hljs-built_in\\">size</span>(); j++)\\n            {\\n                <span class=\\"hljs-keyword\\">if</span> (prefix[j] != strs[i][j])\\n                {\\n                    prefix = prefix.<span class=\\"hljs-built_in\\">substr</span>(<span class=\\"hljs-number\\">0</span>, j);\\n                }\\n            }\\n\\n            <span class=\\"hljs-keyword\\">if</span> (prefix.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">break</span>;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> prefix;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')}}]);