(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["post-2021-11-24-leet_code-17-34"],{"15d2":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---17-letter-combinations-of-a-phone-number\\">LeetCode - 17. Letter Combinations of a Phone Number</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\">LeetCode - 17. Letter Combinations of a Phone Number</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"/assets/images/leet_code/17/example.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>2-9 사이로 구성된 숫자 문자열이 입력으로 들어오면 위 핸드폰 자판에 매핑되는 문자들에 대해서 모든 문자열 조합을 만드는 문제입니다.</p>\\n<p>예를 들어 숫자 <em>23</em>이 입력으로 들어왔다면 <code>2 : abc</code>, <code>3 : def</code>의 조합인 <code>[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]</code>를 구하면 되는 문제입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<p><a href=\\"https://github.com/LDobac/leetcode/tree/master/17.%20Letter%20Combinations%20of%20a%20Phone%20Number\\">My Solutions(Github)</a></p>\\n<h3 id=\\"solution---dfs-backtracking\\">Solution - DFS, Backtracking</h3>\\n<p>본 문제를 처음보자마자 생각난 풀이 방법은 <a href=\\"https://en.wikipedia.org/wiki/Cartesian_product\\">Cartesian product</a>이였습니다.</p>\\n<p><img src=\\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Cartesian_Product_qtl1.svg/330px-Cartesian_Product_qtl1.svg.png\\" alt=\\"Cartessian Product\\"></p>\\n<p>카테시안 곱은 두 집합의 각 원소에 대한 모든 순서쌍을 정의하는 연산입니다. 본 문제 또한 연산의 결과가 카테시안 곱과 동일하게 나타나니 적용가능할 듯 합니다.</p>\\n<p>카테시안 곱을 구현하기 위해서 문제를 트리 형태로 표현해보도록 하겠습니다.</p>\\n<p><img src=\\"/assets/images/leet_code/17/example_2.png\\" alt=\\"tree example\\"></p>\\n<p><code>235</code>라는 숫자가 주어졌다면, 2의 문자에 해당하는 &quot;abc&quot;와 5의 문자에 해당하는 &quot;def&quot;, 그리고 7에 해당하는 &quot;jkl&quot;에 대해서 카테시안 곱 연산을 통해 모든 가짓수를 찾아야 합니다.</p>\\n<p>이를 계산하기 위해서 위 이미지와 각 &#39;a&#39;, &#39;b&#39;, &#39;c&#39;에 대해서 &#39;d&#39;, &#39;e&#39;, &#39;f&#39; 문자가 붙는 경우, 또 깊숙히 내려갈수록 5에 대한 문자열이 붙는 경우에 대해서 트리로 표현할 수 있습니다. 즉, 위 트리가 상태 공간이 되는 것이죠.</p>\\n<p>여기서 필요한 내용은 위 상태 공간 트리의 가장 말단 노드(Leaf node)까지 탐색할 때 과정에서 각 문자의 조합들이 필요합니다. 즉 DFS(깊이 우선 탐색)를 수행하면서 중간에 문자열을 합치다가 말단 노드에 도달하면 해당 문자열을 반환하면 될 것 같습니다.</p>\\n<p>(문제를 푼 후 다른 풀이를 찾아보니, 말단 노드를 탐색 한 후 다시 뒤로 돌아가 다른 경우의 수를 찾기때문에 Backtracking 탐색이라고도 할 수 있을 것 같습니다.)</p>\\n<p>DFS는 스택 또는 재귀 함수로 구현할 수 있습니다. 이번에는 간단하게 재귀 함수로 구현해보겠습니다.</p>\\n<pre><code class=\\"language-c++\\">vector&lt;string&gt; numToLetters = {\\n    <span class=\\"hljs-string\\">&quot;&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;abc&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;def&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;ghi&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;jkl&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;mno&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;pqrs&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;tuv&quot;</span>,\\n    <span class=\\"hljs-string\\">&quot;wxyz&quot;</span>,\\n};\\n</code></pre>\\n<p>먼저 각 숫자에 대해서 문자를 매핑할 수 있도록 별도의 배열을 선언합니다. <code>map</code> STL 자료형을 이용해 딕셔너리나, 해시 테이블의 형태로도 충분히 구현가능합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\">vector&lt;string&gt; <span class=\\"hljs-title\\">letterCombinations</span><span class=\\"hljs-params\\">(string digits)</span> \\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (digits.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">vector</span>&lt;string&gt;();\\n\\n    vector&lt;string&gt; result;\\n\\n    <span class=\\"hljs-built_in\\">com</span>(digits, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-string\\">&quot;&quot;</span>, result);\\n\\n    <span class=\\"hljs-keyword\\">return</span> result;\\n}\\n</code></pre>\\n<p>함수 자체는 재귀 함수만 호출해주는 형태입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">com</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">const</span> string&amp; digits, <span class=\\"hljs-type\\">int</span> digitIndex, string str, vector&lt;string&gt;&amp; out)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (digitIndex == digits.<span class=\\"hljs-built_in\\">size</span>()) \\n    {\\n        out.<span class=\\"hljs-built_in\\">push_back</span>(str);\\n        <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n\\n    string&amp; letters = numToLetters[digits[digitIndex] - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>];\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; letters.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n    {\\n        <span class=\\"hljs-built_in\\">com</span>(digits, digitIndex + <span class=\\"hljs-number\\">1</span>, str + letters[i], out);\\n    }\\n}\\n</code></pre>\\n<p>재귀 함수로 매우 간단합니다. 하나씩 살펴보도록 하겠습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> (digitIndex == digits.<span class=\\"hljs-built_in\\">size</span>()) \\n{\\n    out.<span class=\\"hljs-built_in\\">push_back</span>(str);\\n    <span class=\\"hljs-keyword\\">return</span>;\\n}\\n</code></pre>\\n<p>현재 순회하는 노드가 말단 노드인경우 지금까지 조합한 문자열을 결과 배열에 삽입합니다. Backtracking이므로 이전 노드로 돌아가 다른 경우를 탐색한다고 볼 수 있겠네요.</p>\\n<pre><code class=\\"language-c++\\">string&amp; letters = numToLetters[digits[digitIndex] - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>];\\n</code></pre>\\n<p>현재 입력된 수의 문자들을 가져옵니다. &#39;0&#39;을 빼는 이유는 문자열로 숫자가 입력되기 때문입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; letters.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n{\\n    <span class=\\"hljs-built_in\\">com</span>(digits, digitIndex + <span class=\\"hljs-number\\">1</span>, str + letters[i], out);\\n}\\n</code></pre>\\n<p>그리고 현재 문자들을 순회하면서 새로이 재귀 함수를 호출합니다. 재귀를 호출할때는 현재 탐색하는 숫자 문자의 다음을 선택하고, 지금까지 탐색했던 문자들을 모두 조합하면서 새로운 재귀 함수를 호출합니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/17/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행속도는 0ms입니다. 시간 복잡도는 O(4^n)으로 생각할 수 있을 것 같습니다.</p>\\n<p>트리의 깊이는 입력된 숫자 문자열의 길이와 같습니다. 예를 들어 숫자 2만 주어졌다면 &quot;abc&quot;가 depth=1이 되겠습니다. &quot;23&quot;이 주어진다면 &quot;abc&quot;가 depth=1, 그리고 각 &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 노드마다 &quot;def&quot;의 노드가 붙게됩니다.</p>\\n<p>그리고 숫자 7, 8, 9의 경우 각 문자가 4개씩 되게때문에 최악의 경우 7, 8, 9로만 이루어진 숫자가 입력될 수 있습니다.</p>\\n<p>때문에 O(n^4)로 계산할 수 있겠습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    vector&lt;string&gt; numToLetters = {\\n        <span class=\\"hljs-string\\">&quot;&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;abc&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;def&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;ghi&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;jkl&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;mno&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;pqrs&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;tuv&quot;</span>,\\n        <span class=\\"hljs-string\\">&quot;wxyz&quot;</span>,\\n    };\\n\\n    <span class=\\"hljs-function\\">vector&lt;string&gt; <span class=\\"hljs-title\\">letterCombinations</span><span class=\\"hljs-params\\">(string digits)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (digits.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">vector</span>&lt;string&gt;();\\n\\n        vector&lt;string&gt; result;\\n\\n        <span class=\\"hljs-built_in\\">com</span>(digits, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-string\\">&quot;&quot;</span>, result);\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">com</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">const</span> string&amp; digits, <span class=\\"hljs-type\\">int</span> digitIndex, string str, vector&lt;string&gt;&amp; out)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (digitIndex == digits.<span class=\\"hljs-built_in\\">size</span>()) \\n        {\\n            out.<span class=\\"hljs-built_in\\">push_back</span>(str);\\n            <span class=\\"hljs-keyword\\">return</span>;\\n        }\\n\\n        string&amp; letters = numToLetters[digits[digitIndex] - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>];\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; letters.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n        {\\n            <span class=\\"hljs-built_in\\">com</span>(digits, digitIndex + <span class=\\"hljs-number\\">1</span>, str + letters[i], out);\\n        }\\n        \\n    }\\n};\\n</code></pre>\\n</details>\\n"}')}}]);
//# sourceMappingURL=post-2021-11-24-leet_code-17-34.7dd4c076.js.map