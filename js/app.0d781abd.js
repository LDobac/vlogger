(function(s){function n(n){for(var e,l,c=n[0],r=n[1],i=n[2],o=0,h=[];o<c.length;o++)l=c[o],Object.prototype.hasOwnProperty.call(t,l)&&t[l]&&h.push(t[l][0]),t[l]=0;for(e in r)Object.prototype.hasOwnProperty.call(r,e)&&(s[e]=r[e]);d&&d(n);while(h.length)h.shift()();return p.push.apply(p,i||[]),a()}function a(){for(var s,n=0;n<p.length;n++){for(var a=p[n],e=!0,l=1;l<a.length;l++){var c=a[l];0!==t[c]&&(e=!1)}e&&(p.splice(n--,1),s=r(r.s=a[0]))}return s}var e={},l={app:0},t={app:0},p=[];function c(s){return r.p+"js/"+({post_view:"post_view"}[s]||s)+"."+{post_view:"319a52a4"}[s]+".js"}function r(n){if(e[n])return e[n].exports;var a=e[n]={i:n,l:!1,exports:{}};return s[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.e=function(s){var n=[],a={post_view:1};l[s]?n.push(l[s]):0!==l[s]&&a[s]&&n.push(l[s]=new Promise((function(n,a){for(var e="css/"+({post_view:"post_view"}[s]||s)+"."+{post_view:"bbaf5dcc"}[s]+".css",t=r.p+e,p=document.getElementsByTagName("link"),c=0;c<p.length;c++){var i=p[c],o=i.getAttribute("data-href")||i.getAttribute("href");if("stylesheet"===i.rel&&(o===e||o===t))return n()}var h=document.getElementsByTagName("style");for(c=0;c<h.length;c++){i=h[c],o=i.getAttribute("data-href");if(o===e||o===t)return n()}var d=document.createElement("link");d.rel="stylesheet",d.type="text/css",d.onload=n,d.onerror=function(n){var e=n&&n.target&&n.target.src||t,p=new Error("Loading CSS chunk "+s+" failed.\n("+e+")");p.code="CSS_CHUNK_LOAD_FAILED",p.request=e,delete l[s],d.parentNode.removeChild(d),a(p)},d.href=t;var j=document.getElementsByTagName("head")[0];j.appendChild(d)})).then((function(){l[s]=0})));var e=t[s];if(0!==e)if(e)n.push(e[2]);else{var p=new Promise((function(n,a){e=t[s]=[n,a]}));n.push(e[2]=p);var i,o=document.createElement("script");o.charset="utf-8",o.timeout=120,r.nc&&o.setAttribute("nonce",r.nc),o.src=c(s);var h=new Error;i=function(n){o.onerror=o.onload=null,clearTimeout(d);var a=t[s];if(0!==a){if(a){var e=n&&("load"===n.type?"missing":n.type),l=n&&n.target&&n.target.src;h.message="Loading chunk "+s+" failed.\n("+e+": "+l+")",h.name="ChunkLoadError",h.type=e,h.request=l,a[1](h)}t[s]=void 0}};var d=setTimeout((function(){i({type:"timeout",target:o})}),12e4);o.onerror=o.onload=i,document.head.appendChild(o)}return Promise.all(n)},r.m=s,r.c=e,r.d=function(s,n,a){r.o(s,n)||Object.defineProperty(s,n,{enumerable:!0,get:a})},r.r=function(s){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(s,"__esModule",{value:!0})},r.t=function(s,n){if(1&n&&(s=r(s)),8&n)return s;if(4&n&&"object"===typeof s&&s&&s.__esModule)return s;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:s}),2&n&&"string"!=typeof s)for(var e in s)r.d(a,e,function(n){return s[n]}.bind(null,e));return a},r.n=function(s){var n=s&&s.__esModule?function(){return s["default"]}:function(){return s};return r.d(n,"a",n),n},r.o=function(s,n){return Object.prototype.hasOwnProperty.call(s,n)},r.p="/",r.oe=function(s){throw console.error(s),s};var i=window["webpackJsonp"]=window["webpackJsonp"]||[],o=i.push.bind(i);i.push=n,i=i.slice();for(var h=0;h<i.length;h++)n(i[h]);var d=o;p.push([0,"chunk-vendors"]),a()})({0:function(s,n,a){s.exports=a("cd49")},"0919":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---5-longest-palindromic-substring\\">LeetCode - 5. Longest Palindromic Substring</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/longest-palindromic-substring/\\">LeetCode 5. Longest Palindromic Substring</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"https://uselessetymology.files.wordpress.com/2019/10/palindrome-useless-etymology-12.png\\" alt=\\"Palindrome example\\"></p>\\n<p>이번 문제는 주어진 문자열에서 가장 긴 회문(Palindrome)을 구하는 문제입니다.</p>\\n<p>회문은 위의 예시 이미지와 같이 문자열을 뒤집어도 동일한 문자열인 경우를 말합니다.</p>\\n<p>다만, 이번 문제에서는 주어진 문자열이 회문이 아닌, 문자열 내에서 회문인 가장 긴 부분 문자열을 반환하는 문제입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>첫 번째로 시도한 방법은 Brute force, 단순히 2중 반복문을 통하여 문자열을 n...j까지 n과 j를 1씩 늘려가며 회문인지 검사하고 반환하는 방법입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n{\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n    {\\n        <span class=\\"hljs-keyword\\">auto</span> substr = std::<span class=\\"hljs-built_in\\">string_view</span>(&amp;s[i], (j - i) + <span class=\\"hljs-number\\">1</span>);\\n        <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-built_in\\">isPalindrome</span>(substr))\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (longestLength &lt; (j - i) + <span class=\\"hljs-number\\">1</span>)\\n            {\\n                longestLength = (j - i) + <span class=\\"hljs-number\\">1</span>;\\n                start = i;\\n            }\\n        }\\n    }\\n}\\n\\n<span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, longestLength);\\n...\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isPalindrome</span><span class=\\"hljs-params\\">(<span class=\\"hljs-keyword\\">const</span> std::string_view&amp; s)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">auto</span> length = s.<span class=\\"hljs-built_in\\">size</span>();\\n\\n    <span class=\\"hljs-keyword\\">for</span> (std::<span class=\\"hljs-type\\">size_t</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; length; i++)\\n    {\\n        <span class=\\"hljs-keyword\\">if</span> (s[i] != s[length - i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n    }\\n    \\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n}\\n</code></pre>\\n<p>회문을 찾을 수 있는 아주 간단한 방법입니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/5/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>하지만 위 코드를 제출하니 Time Limite Exeeded, 시간 초과가 발생하였습니다.</p>\\n<p>위 코드는 i..j까지 반복문을 순회할 때의 시간 복잡도는 O(n^2)이며, 회문을 검사하는 코드의 시간 복잡도는 O(n)입니다. 즉 최종적으로 시간 복잡도가 O(n^3)의 코드이기에 매우 긴 문자열을 검사할 때 시간 초과가 발생하게 되었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string_view&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">longestPalindrome</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span> || s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> start = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n        {\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n            {\\n                <span class=\\"hljs-keyword\\">auto</span> substr = std::<span class=\\"hljs-built_in\\">string_view</span>(&amp;s[i], (j - i) + <span class=\\"hljs-number\\">1</span>);\\n                <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-built_in\\">isPalindrome</span>(substr))\\n                {\\n                    <span class=\\"hljs-keyword\\">if</span> (longestLength &lt; (j - i) + <span class=\\"hljs-number\\">1</span>)\\n                    {\\n                        longestLength = (j - i) + <span class=\\"hljs-number\\">1</span>;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, longestLength);\\n    }\\n\\n<span class=\\"hljs-keyword\\">private</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isPalindrome</span><span class=\\"hljs-params\\">(<span class=\\"hljs-keyword\\">const</span> std::string_view&amp; s)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">auto</span> length = s.<span class=\\"hljs-built_in\\">size</span>();\\n\\n        <span class=\\"hljs-keyword\\">for</span> (std::<span class=\\"hljs-type\\">size_t</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; length; i++)\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (s[i] != s[length - i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2---dynamic-programming\\">Solution 2 - Dynamic programming</h3>\\n<p>두 번째 방법은 동적 프로그래밍(Dynamic programming)을 이용한 풀이입니다.</p>\\n<p>회문의 특성을 생각해볼때 만약 <em>abcba</em>라는 회문 문자열이 존재한다면 해당 문자열의 부분 문자열 <em>bcb</em>또한 회문이며, <em>bcb</em>의 부분 문자열 <em>c</em>또한 회문임을 알 수 있습니다.</p>\\n<p>두 번째로 문자가 하나인 경우 <em>c</em>와 같은 경우는 무조건 회문입니다. 그리고 만약 <em>c</em>의 앞뒤로 문자가 하나씩 추가 될 때 두 문자가 같다면, <em>bcb</em>가 된다면 이 또한 회문이 됩니다.</p>\\n<p>이러한 특성과 동적 프로그래밍을 이미 회문을 검사한 문자열을 또 검사하지 않고 새로운 회문 문자열을 찾을 수 있습니다.</p>\\n<p>먼저 규칙을 정의합니다.</p>\\n<ol>\\n<li>S(i, j) : 문자열 S에 대해서 i번째부터 j번째까지의 부분 문자열</li>\\n<li>S(i, i) = 회문</li>\\n<li>S(i, i+1) = S_i == S_i+1일 경우 회문</li>\\n<li>S(i, j) = S(i+1, j-1) &amp;&amp; S_i == S_j 일 경우 회문</li>\\n</ol>\\n<p>2번 규칙의 경우 S(i, i)는 S문자열의 i번째부터 i번째까지 부분 문자열, 즉 하나의 문자에 대해서 회문임을 확인하기에 무조건 회문입니다.</p>\\n<p>3번 규칙은 S(i, i+1)는 선택한 문자와 인접한 문자가 같다면 회문임을 나타냅니다. <strong>&quot;bb&quot;</strong> 와 같은 경우를 나타냅니다.</p>\\n<p>4번 규칙은 위에서 말했듯이 부분 문자열이 회문이고, 앞 뒤로 추가되는 문자열이 같다면 새로 추가되는 문자열도 회문임을 나타냅니다.</p>\\n<pre><code class=\\"language-c++\\">std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">bool</span>&gt;&gt; <span class=\\"hljs-built_in\\">dp</span>(s.<span class=\\"hljs-built_in\\">size</span>(), std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">bool</span>&gt;(s.<span class=\\"hljs-built_in\\">size</span>(), <span class=\\"hljs-literal\\">false</span>));\\n</code></pre>\\n<p><code>std::vector</code> STL 컨테이너를 이용해 2차원 동적 배열을 선언합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span> ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n{\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt;= j ; i++)\\n    {\\n        <span class=\\"hljs-type\\">bool</span> same = s[i] == s[j];\\n\\n        <span class=\\"hljs-comment\\">// 문자열 길이가 2이상일때는 dp[i + 1][j - 1]즉, substr이 회문이여야 함</span>\\n        <span class=\\"hljs-comment\\">// 문자열 길이가 2일경우(i, i+1) 두 문자가 같아야 회문</span>\\n        <span class=\\"hljs-comment\\">// 문자열 길이가 1일경우 무조건 회문</span>\\n        dp[i][j] = j - i &gt; <span class=\\"hljs-number\\">2</span> ? (dp[i + <span class=\\"hljs-number\\">1</span>][j - <span class=\\"hljs-number\\">1</span>] &amp;&amp; same) : same;\\n        \\n        <span class=\\"hljs-keyword\\">if</span> ((longestLen &lt; (j - i + <span class=\\"hljs-number\\">1</span>)) &amp;&amp; dp[i][j])\\n        {\\n            longestLen = j - i + <span class=\\"hljs-number\\">1</span>;\\n            start = i;\\n        }\\n    }\\n}\\n</code></pre>\\n<p>i와 j는 각각 S(i, j)로 부분문자열 시작 index인 i부터 j까지를 나타냅니다. </p>\\n<p>j - i가 2보다 작으면 규칙 2와 규칙 3을 적용할 수 있기에 단순히 S_i와 S_j를 비교한 결과가 저장됩니다.</p>\\n<p>j - i가 2보다 큰 경우는 문자열의 길이가 최소 3이상이므로 부분 문자열이 회문인지 검사하고 새로 추가된 문자 둘이 같은지 확인해야 합니다. S(i, j)의 부분 문자열 S(i+1, j-1)은 이미 계산이 되어 배열에 삽입되어 있을태니 추가로 계산할 필요 없이 값을 조회만 하면 됩니다.</p>\\n<p>마지막으로 지금 확인한 문자열이 회문이고 가장 길다면 해당 문자열의 인덱스를 저장합니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/5/result_2.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>1번 해결 방법의 경우 O(n^3)이기 때문에 시간 초과가 발생했지만, 이번 방법의 경우 O(n^2)의 시간 복잡도이기 때문에 시간 초과가 발생하지 않았습니다.</p>\\n<p>784ms 시간이 소요되었으며 다른 C++코드 제출자에 비해서 10% 정도의 성능밖에 보이지 않았습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string_view&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">longestPalindrome</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span> || s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLen = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> start = <span class=\\"hljs-number\\">0</span>;\\n\\n        std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">bool</span>&gt;&gt; <span class=\\"hljs-built_in\\">dp</span>(s.<span class=\\"hljs-built_in\\">size</span>(), std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">bool</span>&gt;(s.<span class=\\"hljs-built_in\\">size</span>(), <span class=\\"hljs-literal\\">false</span>));\\n\\n        <span class=\\"hljs-comment\\">// 열 기반으로 탐색</span>\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span> ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n        {\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt;= j ; i++)\\n            {\\n                <span class=\\"hljs-type\\">bool</span> same = s[i] == s[j];\\n\\n                <span class=\\"hljs-comment\\">// 문자열 길이가 2이상일때는 dp[i + 1][j - 1]즉, substr이 회문이여야 함</span>\\n                <span class=\\"hljs-comment\\">// 문자열 길이가 2일경우(i, i+1) 두 문자가 같아야 회문</span>\\n                <span class=\\"hljs-comment\\">// 문자열 길이가 1일경우 무조건 회문</span>\\n                dp[i][j] = j - i &gt; <span class=\\"hljs-number\\">2</span> ? (dp[i + <span class=\\"hljs-number\\">1</span>][j - <span class=\\"hljs-number\\">1</span>] &amp;&amp; same) : same;\\n                \\n                <span class=\\"hljs-keyword\\">if</span> ((longestLen &lt; (j - i + <span class=\\"hljs-number\\">1</span>)) &amp;&amp; dp[i][j])\\n                {\\n                    longestLen = j - i + <span class=\\"hljs-number\\">1</span>;\\n                    start = i;\\n                }\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, longestLen);\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-3---expand-around-center\\">Solution 3 - Expand around center</h3>\\n<p>회문을 검사하기 위해서는 문자열을 시작과 끝을 정해서 회문을 검사하는 방법도 있지만, 문자열의 가운데부터 좌우로 확장하면서 회문임을 검사하는 방법도 있습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n{\\n    <span class=\\"hljs-type\\">int</span> len1 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i);\\n    <span class=\\"hljs-type\\">int</span> len2 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i + <span class=\\"hljs-number\\">1</span>);\\n    <span class=\\"hljs-type\\">int</span> len = std::<span class=\\"hljs-built_in\\">max</span>(len1, len2);\\n\\n    <span class=\\"hljs-keyword\\">if</span> (len &gt; end - start)\\n    {\\n        start = i - (len - <span class=\\"hljs-number\\">1</span>) / <span class=\\"hljs-number\\">2</span>;\\n        end = i + len / <span class=\\"hljs-number\\">2</span>;\\n    }\\n}\\n</code></pre>\\n<p><code>expandAroundCenter</code> 함수는 i를 기준으로 좌우로 확장하며 회문인지 검사하는 함수입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">expandAroundCenter</span><span class=\\"hljs-params\\">(<span class=\\"hljs-keyword\\">const</span> std::string&amp; s, <span class=\\"hljs-type\\">int</span> left, <span class=\\"hljs-type\\">int</span> right)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">while</span> ( left &gt;= <span class=\\"hljs-number\\">0</span> &amp;&amp; right &lt; s.<span class=\\"hljs-built_in\\">size</span>() &amp;&amp; s[left] == s[right])\\n    {\\n        left--;\\n        right++;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> right - left - <span class=\\"hljs-number\\">1</span>;\\n}\\n</code></pre>\\n<p><code>expandAroundCenter</code> 함수를 i와 i+1에 대해서 호출하는 이유는 문자열이 짝수인경우 회문의 중앙 문자가 2개가 존재하기 때문에 두 경우 중 긴 문자열을 선택합니다.</p>\\n<h4 id=\\"제출-결과-2\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/5/result_3.png\\" alt=\\"Solution 3 result\\"></p>\\n<p>이번 방법의 시간 복잡도는 O(n^2)이며 동적 프로그래밍과 동일합니다. 다만 공간 복잡도가 동적 프로그래밍은 O(n^2)이지만, 이번 방법의 공간 복잡도는 O(1)이기때문에 동적 프로그래밍 방법과 비교하면 메모리 사용량에서 많은 차이가 발생함을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;algorithm&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">longestPalindrome</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span> || s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n\\n        <span class=\\"hljs-type\\">int</span> start = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> end = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n        {\\n            <span class=\\"hljs-type\\">int</span> len1 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i);\\n            <span class=\\"hljs-type\\">int</span> len2 = <span class=\\"hljs-built_in\\">expandAroundCenter</span>(s, i, i + <span class=\\"hljs-number\\">1</span>);\\n            <span class=\\"hljs-type\\">int</span> len = std::<span class=\\"hljs-built_in\\">max</span>(len1, len2);\\n\\n            <span class=\\"hljs-keyword\\">if</span> (len &gt; end - start)\\n            {\\n                start = i - (len - <span class=\\"hljs-number\\">1</span>) / <span class=\\"hljs-number\\">2</span>;\\n                end = i + len / <span class=\\"hljs-number\\">2</span>;\\n            }\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> s.<span class=\\"hljs-built_in\\">substr</span>(start, (end - start) + <span class=\\"hljs-number\\">1</span>);\\n    }\\n<span class=\\"hljs-keyword\\">private</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">expandAroundCenter</span><span class=\\"hljs-params\\">(<span class=\\"hljs-keyword\\">const</span> std::string&amp; s, <span class=\\"hljs-type\\">int</span> left, <span class=\\"hljs-type\\">int</span> right)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">while</span> ( left &gt;= <span class=\\"hljs-number\\">0</span> &amp;&amp; right &lt; s.<span class=\\"hljs-built_in\\">size</span>() &amp;&amp; s[left] == s[right])\\n        {\\n            left--;\\n            right++;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> right - left - <span class=\\"hljs-number\\">1</span>;\\n    }\\n};\\n</code></pre>\\n</details>"}')},"09f0":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---6-zigzag-conversion\\">LeetCode - 6. Zigzag Conversion</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/zigzag-conversion/\\">LeetCode 6. Zigzag Conversion</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>지그재그 변환은 문자열을 지그재그로 변환하는 문제입니다.</p>\\n<p>예를 들어 문자열 <code>HELLOWORLD</code>가 있다면</p>\\n<pre><code>H     W\\nE   W O\\nL O   R D\\nL     L\\n</code></pre>\\n<p>와 같이 변환하여 최종적으로 <code>HWEWOLORDLL</code>로 변환하는게 목표입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution\\">Solution</h3>\\n<p>제가 풀이한 방법은 지그재그의 규칙을 찾아 수식으로 계산하는 방법을 이용하였습니다.</p>\\n<p><img src=\\"/assets/images/leet_code/6/example.png\\" alt=\\"example equation\\"></p>\\n<p>문자열을 Row가 3, 4, 5일때 열 인덱스를 초록색으로 표시하였고, 빨간색 숫자로 일반 문자열의 인덱스를 표현하였다.</p>\\n<p>첫 번째 열과 마지막 열의 문자열의 인덱스는 row + (numOfRow - 1)*2로 표현할 수 있다</p>\\n<p>그리고 중간 열에는 무조건 중간에 문자가 하나씩 존재한다. 중간에 위치한 문자의 인덱스는 (row + (numOfRow - 1)*2) - ((row-1)*2)로 표현할 수 있다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/6/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>12ms의 실행 속도가 나왔으며, 다른 C++ 제출자에 비해 약 60%가량 좋은 성능을 보이게 되었다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::string <span class=\\"hljs-title\\">convert</span><span class=\\"hljs-params\\">(std::string s, <span class=\\"hljs-type\\">int</span> numRows)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (numRows &lt;= <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> s;\\n        \\n        <span class=\\"hljs-type\\">bool</span> middle = <span class=\\"hljs-literal\\">false</span>;\\n        <span class=\\"hljs-type\\">int</span> curRow = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>;\\n        std::string result = <span class=\\"hljs-string\\">&quot;&quot;</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span> (result.<span class=\\"hljs-built_in\\">size</span>() != s.<span class=\\"hljs-built_in\\">size</span>())\\n        {\\n            <span class=\\"hljs-type\\">int</span> index = curRow + (i * ((numRows - <span class=\\"hljs-number\\">1</span>) * <span class=\\"hljs-number\\">2</span>));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (curRow % (numRows - <span class=\\"hljs-number\\">1</span>) != <span class=\\"hljs-number\\">0</span>)\\n            {\\n                <span class=\\"hljs-keyword\\">if</span> (middle)\\n                {\\n                    index -= (curRow * <span class=\\"hljs-number\\">2</span>);\\n                    i--;\\n                    middle = <span class=\\"hljs-literal\\">false</span>;\\n                }\\n                <span class=\\"hljs-keyword\\">else</span>\\n                {\\n                    middle = <span class=\\"hljs-literal\\">true</span>;\\n                }\\n            }\\n\\n            <span class=\\"hljs-keyword\\">if</span> (index &gt;= s.<span class=\\"hljs-built_in\\">size</span>())\\n            {\\n                curRow++;\\n                middle = <span class=\\"hljs-literal\\">false</span>;\\n                i = <span class=\\"hljs-number\\">0</span>;\\n\\n                <span class=\\"hljs-keyword\\">continue</span>;\\n            }\\n\\n            result += s[index];\\n\\n            i++;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},"0e31":function(s,n,a){},"14b9":function(s){s.exports=JSON.parse('[{"uid":1,"title":"LeetCode - 1. Two Sum","summery":"","thumbnail":"","date":"2021-10-24T22:10:27.000+00:00","series":1,"tags":[1,2,3],"originFile":"2021-10-24-leet_code_1.md","htmlFileName":"2021-10-24-leet_code_1.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-10-24-leet_code_1.json","mtime":1636733517094.7886},{"uid":2,"title":"LeetCode - 2. Add Two Numbers","summery":"","thumbnail":"","date":"2021-10-26T22:21:00.000+00:00","series":1,"tags":[1,4,3],"originFile":"2021-10-26-leet_code_2.md","htmlFileName":"2021-10-26-leet_code_2.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-10-26-leet_code_2.json","mtime":1636733517094.7886},{"uid":3,"title":"LeetCode - 3. Longest Substring Without Repeating Characters","summery":"","thumbnail":"","date":"2021-10-27T21:47:50.000+00:00","series":1,"tags":[1,4,3],"originFile":"2021-10-27-leet_code_3.md","htmlFileName":"2021-10-27-leet_code_3.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-10-27-leet_code_3.json","mtime":1636733517094.7886},{"uid":4,"title":"LeetCode - 4. Median of Two Sorted Arrays","summery":"","thumbnail":"","date":"2021-10-29T17:36:45.000+00:00","series":1,"tags":[1,5,3],"originFile":"2021-10-29-leet_code_4.md","htmlFileName":"2021-10-29-leet_code_4.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-10-29-leet_code_4.json","mtime":1636733517094.7886},{"uid":5,"title":"LeetCode - 5. Longest Palindromic Substring","summery":"","thumbnail":"","date":"2021-11-06T23:49:00.000+00:00","series":1,"tags":[1,4,3],"originFile":"2021-11-06-leet_code_5.md","htmlFileName":"2021-11-06-leet_code_5.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-06-leet_code_5.json","mtime":1636733517094.7886},{"uid":6,"title":"LeetCode - 6. Zigzag Conversion","summery":"","thumbnail":"","date":"2021-11-07T19:29:40.000+00:00","series":1,"tags":[1,4,3],"originFile":"2021-11-07-leet_code_6.md","htmlFileName":"2021-11-07-leet_code_6.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-07-leet_code_6.json","mtime":1636733517094.7886},{"uid":7,"title":"LeetCode - 7. Reverse Integer","summery":"","thumbnail":"","date":"2021-11-08T14:07:30.000+00:00","series":1,"tags":[1,4,3],"originFile":"2021-11-08-leet_code_7.md","htmlFileName":"2021-11-08-leet_code_7.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-08-leet_code_7.json","mtime":1636733517094.7886},{"uid":8,"title":"LeetCode - 8. String to Integer (atoi)","summery":"","thumbnail":"","date":"2021-11-08T15:00:00.000+00:00","series":1,"tags":[1,4,3],"originFile":"2021-11-08-leet_code_8.md","htmlFileName":"2021-11-08-leet_code_8.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-08-leet_code_8.json","mtime":1636733517094.7886},{"uid":9,"title":"LeetCode - 9. Palindrome Number","summery":"","thumbnail":"","date":"2021-11-08T15:21:00.000+00:00","series":1,"tags":[1,2,3],"originFile":"2021-11-08-leet_code_9.md","htmlFileName":"2021-11-08-leet_code_9.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-08-leet_code_9.json","mtime":1636733517094.7886},{"uid":10,"title":"LeetCode - 10. Regular Expression Matching","summery":"","thumbnail":"","date":"2021-11-10T22:23:11.000+00:00","series":1,"tags":[1,5,3],"originFile":"2021-11-10-leet_code_10.md","htmlFileName":"2021-11-10-leet_code_10.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-10-leet_code_10.json","mtime":1636733517094.7886},{"uid":11,"title":"LeetCode - 11. Container With Most Water","summery":"","thumbnail":"","date":"2021-11-12T16:13:50.907+00:00","series":1,"tags":[1,4,3],"originFile":"2021-11-13-leet_code_11.md","htmlFileName":"2021-11-13-leet_code_11.json","htmlFilePath":"/home/runner/work/vlogger/vlogger/src/assets/.build/build_posts/2021-11-13-leet_code_11.json","mtime":1636733517094.7886}]')},"1b53":function(s,n,a){},"1d16":function(s,n,a){},"25b4":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---11-container-with-most-water\\">LeetCode - 11. Container With Most Water</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/container-with-most-water/\\">LeetCode 11. Container With Most Water</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"/assets/images/leet_code/11/question_11.jpg\\" alt=\\"challenge example\\"></p>\\n<p>배열에 순서대로 각 막대의 길이가 주어 질 때, 해당 막대 사이에 액체를 담을 때 가장 많이 담긴 양을 구하는 문제입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>첫 번째 방법은 먼저 간단히 Brute force, 무차별 대입을 통한 문제 풀이를 시도해보도록 하겠습니다.</p>\\n<p>중첩된 반복문을 사용해 두 막대를 선택해 가장 큰 크기를 선택합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> maxArea = <span class=\\"hljs-number\\">0</span>;\\n\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; count - <span class=\\"hljs-number\\">1</span>; i++)\\n{\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i; j &lt; count; j++)\\n    {\\n        <span class=\\"hljs-type\\">int</span> barHeight = std::<span class=\\"hljs-built_in\\">min</span>(height[i], height[j]);\\n        <span class=\\"hljs-type\\">int</span> barWidth = j - i;\\n\\n        <span class=\\"hljs-type\\">int</span> area = barWidth * barHeight;\\n\\n        <span class=\\"hljs-keyword\\">if</span> (area &gt; maxArea)\\n        {\\n            maxArea = area;\\n        }\\n    }\\n}\\n</code></pre>\\n<p>넓이를 구하기 위해서는 너비(width)와 높이(height)가 필요합니다. </p>\\n<p>두 막대의 높이가 같다면 둘 중 하나의 높이를 사용할 수 있지만, 만약 높이가 다를때 액체를 담는다고 상상하면 낮은쪽의 높이로 액체가 넘치게 되겠죠. 그러므로 둘 중 높이가 낮은쪽을 선택합니다.</p>\\n<p>너비도 간단히 구할 수 있습니다. 두 막대 사이의 거리를 계산합니다.ㄹ</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/11/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>중첩된 반복문을 사용하고 있기에 시간 복잡도는 O(n^2)의 성능을 보이게 됩니다. 아주 많은 입력이 주어졌을 때 시간 초과가 발생함을 확인할 수 있었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;algorithm&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">maxArea</span><span class=\\"hljs-params\\">(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; height)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (height.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">2</span>)\\n        {\\n            <span class=\\"hljs-keyword\\">return</span>  std::<span class=\\"hljs-built_in\\">min</span>(height[<span class=\\"hljs-number\\">0</span>], height[<span class=\\"hljs-number\\">1</span>]);\\n        }\\n\\n        <span class=\\"hljs-type\\">int</span> count = height.<span class=\\"hljs-built_in\\">size</span>();\\n\\n        <span class=\\"hljs-type\\">int</span> maxArea = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; count - <span class=\\"hljs-number\\">1</span>; i++)\\n        {\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i; j &lt; count; j++)\\n            {\\n                <span class=\\"hljs-type\\">int</span> barHeight = std::<span class=\\"hljs-built_in\\">min</span>(height[i], height[j]);\\n                <span class=\\"hljs-type\\">int</span> barWidth = j - i;\\n\\n                <span class=\\"hljs-type\\">int</span> area = barWidth * barHeight;\\n\\n                <span class=\\"hljs-keyword\\">if</span> (area &gt; maxArea)\\n                {\\n                    maxArea = area;\\n                }\\n            }\\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> maxArea;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2\\">Solution 2</h3>\\n<p>두 번째 방법은 첫 번째 방법에서 약간 개선하여 굳이 의미 없는 계산을 빼보도록 하겠습니다.</p>\\n<p>높이가 가장 큰 두 개의 막대를 선택한다 하더라도 너비가 너무 좁으면 다른 것보다 넓이가 작을 수도 있습니다.</p>\\n<p>때문에 맨 처음에는 가장 너비가 큰 상태인 첫 번째 막대와 마지막 막대를 선택합니다.</p>\\n<p><img src=\\"/assets/images/leet_code/11/selection_example_1.png\\" alt=\\"Selection example\\"></p>\\n<p>여기서 넓이가 더 커질 수 있는 방법은 왼쪽의 막대가 더 높아진다면 넓이가 더 커질 것입니다. 즉, 오른쪽의 막대는 충분히 길지만, 왼쪽의 막대가 작기때문에 왼쪽 막대로는 기대치 이상의 넓이를 구할 수 없을 것 같습니다.</p>\\n<p>왼쪽 막대를 한 칸 오른쪽의 막대를 선택합니다.</p>\\n<p><img src=\\"/assets/images/leet_code/11/selection_example_2.png\\" alt=\\"Selection example 2\\"></p>\\n<p>너비가 1 줄어들었지만, 높이가 너비 이상으로 증가했기 때문에 이전의 결과보다 더 증가하였습니다. </p>\\n<p>현재 상황으로는 오른쪽의 막대가 왼쪽 막대보다 높이가 낮기 때문에, 오른쪽의 막대가 더 길어진다면 넓이가 더 증가할 수 도 있을 것 같습니다. 오른쪽의 막대를 한 칸 왼쪽의 막대를 선택합니다.</p>\\n<p><img src=\\"/assets/images/leet_code/11/selection_example_3.png\\" alt=\\"Selection example 3\\"></p>\\n<p>아쉽지만 오히려 넓이가 낮아졌습니다. 이유는 오른쪽의 막대가 왼쪽의 막대보다 높이가 낮기 때문입니다. 다시 한 번 왼쪽으로 이동합니다.</p>\\n<p><img src=\\"/assets/images/leet_code/11/selection_example_4.png\\" alt=\\"Selection example 4\\"></p>\\n<p>이런방식으로 계속 순회하며 가장 넓이가 컸었던 값을 선택하면 됩니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> maxArea = <span class=\\"hljs-number\\">0</span>;\\n\\n<span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n<span class=\\"hljs-type\\">int</span> right = height.<span class=\\"hljs-built_in\\">size</span>() <span class=\\"hljs-number\\">-1</span>;\\n\\n<span class=\\"hljs-keyword\\">while</span> (left &lt; right)\\n{\\n    <span class=\\"hljs-type\\">int</span> area = std::<span class=\\"hljs-built_in\\">min</span>(height[left], height[right]) * (right - left);\\n\\n    maxArea = std::<span class=\\"hljs-built_in\\">max</span>(area, maxArea);\\n\\n    <span class=\\"hljs-keyword\\">if</span> (height[left] &lt; height[right]) left++;\\n    <span class=\\"hljs-keyword\\">else</span> right--; \\n}\\n\\n<span class=\\"hljs-keyword\\">return</span> maxArea;\\n</code></pre>\\n<p>이런 방식으로 순회를 하면 모든 경우를 검사하는 것이 아니기 때문에 최선의 값을 못 찾아 낼 수 있지 않을까? 라는 생각이 들었습니다.</p>\\n<p>하지만 조금만 생각하니 모든 경우를 검사하지 않더라도 최선의 경우가 나오는지 알 수 있었습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> (height[left] &lt; height[right]) left++;\\n<span class=\\"hljs-keyword\\">else</span> right--; \\n</code></pre>\\n<p>한 쪽의 막대가 다른쪽의 막대보다 작으면 인덱스를 1 올리거나, 1을 내려 다음 막대를 선택합니다.</p>\\n<p>위 코드를 계속해서 실행하게되면 계속해서 두 막대가 경쟁하면서 가장 긴 막대를 선택하려고 시도하게 됩니다. 물론 높이가 가장 높은 두 막대를 선택하더라도 너비가 좁아 더 넓은 공간이 계산되지 않을 수 있습니다.</p>\\n<p>하지만, 결국 높은 막대를 선택하면 큰 넓이가 나올 수 있는 기대치가 있기 때문에 기대치가 있는 경우에 대해서만 검사하므로 이런 결과가 나오게 되게 됩니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/11/result_2.png\\" alt=\\"Solution 2 result\\"></p>\\n<p>시간 복잡도는 O(n)이며 실제 실행 시간은 76ms가 나오며 다른 C++ 제출자보다 91% 가량 좋은 성능을 보임을 알 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;algorithm&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">maxArea</span><span class=\\"hljs-params\\">(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; height)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (height.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">2</span>)\\n        {\\n            <span class=\\"hljs-keyword\\">return</span>  std::<span class=\\"hljs-built_in\\">min</span>(height[<span class=\\"hljs-number\\">0</span>], height[<span class=\\"hljs-number\\">1</span>]);\\n        }\\n\\n        <span class=\\"hljs-type\\">int</span> maxArea = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> right = height.<span class=\\"hljs-built_in\\">size</span>() <span class=\\"hljs-number\\">-1</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span> (left &lt; right)\\n        {\\n            <span class=\\"hljs-type\\">int</span> area = std::<span class=\\"hljs-built_in\\">min</span>(height[left], height[right]) * (right - left);\\n\\n            maxArea = std::<span class=\\"hljs-built_in\\">max</span>(area, maxArea);\\n\\n            <span class=\\"hljs-keyword\\">if</span> (height[left] &lt; height[right]) left++;\\n            <span class=\\"hljs-keyword\\">else</span> right--; \\n        }\\n        \\n        <span class=\\"hljs-keyword\\">return</span> maxArea;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},"2b22":function(s,n,a){"use strict";a("6683")},"2fa2":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---8-string-to-integer-atoi\\">LeetCode - 8. String to Integer (atoi)</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/string-to-integer-atoi/\\">LeetCode 8. String to Integer (atoi)</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>문자열에서 정수형으로 parse하는 atoi 함수를 구현하는 문제입니다.</p>\\n<p>문자열에서 정수형으로 변환할 때 지켜야할 여러 규칙이 존재합니다.</p>\\n<ol>\\n<li>공백 문자는 모두 무시한다.</li>\\n<li>&#39;-&#39;, &#39;+&#39; 문자가 처음으로 등장하고 이미 등장한적이 없다면 각 부호가 정수의 부호를 결정합니다. 만약 어떠한 부호도 등장하지 않았다면 양수로 가정합니다.</li>\\n<li>숫자 문자가 아닌 문자가 등장하면 남은 모든 문자는 무시합니다.</li>\\n<li>숫자 문자는 정수형으로 변환합니다. 만약 숫자가 아니라면 정수 값은 0으로 결정됩니다.</li>\\n<li>만약 정수형 범위를 벗어난다면 정수형 범위의 최대,최소 값을 반환합니다.</li>\\n</ol>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution\\">Solution</h3>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> index = <span class=\\"hljs-number\\">0</span>; index &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; index++)\\n{\\n    <span class=\\"hljs-type\\">char</span> chr = s[index];\\n    \\n    ...\\n}\\n</code></pre>\\n<p>먼저 문자열을 순회합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> ((chr &lt; <span class=\\"hljs-string\\">&#x27;0&#x27;</span> || chr &gt; <span class=\\"hljs-string\\">&#x27;9&#x27;</span>) &amp;&amp; !((result == <span class=\\"hljs-number\\">0</span>) &amp;&amp; (chr == <span class=\\"hljs-string\\">&#x27;+&#x27;</span> || chr == <span class=\\"hljs-string\\">&#x27;-&#x27;</span>)))\\n{\\n    <span class=\\"hljs-keyword\\">if</span> (result == <span class=\\"hljs-number\\">0</span> &amp;&amp; !(chr == <span class=\\"hljs-string\\">&#x27;+&#x27;</span> || chr == <span class=\\"hljs-string\\">&#x27;-&#x27;</span> || chr == <span class=\\"hljs-string\\">&#x27; &#x27;</span>)) <span class=\\"hljs-keyword\\">break</span>;\\n    <span class=\\"hljs-keyword\\">if</span> (chr == <span class=\\"hljs-string\\">&#x27;.&#x27;</span>) <span class=\\"hljs-keyword\\">break</span>;\\n\\n    <span class=\\"hljs-keyword\\">if</span> (findSign) <span class=\\"hljs-keyword\\">break</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">continue</span>;\\n}\\n</code></pre>\\n<p>순회시 숫자 문자가 아니거나, 이미 부호가 결정되었을 때 -, + 문자가 탐색되는 경우를 처리합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">if</span> (chr == <span class=\\"hljs-string\\">&#x27;+&#x27;</span>) \\n{\\n    <span class=\\"hljs-keyword\\">if</span> (findSign) <span class=\\"hljs-keyword\\">break</span>;\\n    neg = <span class=\\"hljs-literal\\">false</span>;\\n    findSign = <span class=\\"hljs-literal\\">true</span>;\\n}\\n<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (chr == <span class=\\"hljs-string\\">&#x27;-&#x27;</span>) \\n{\\n    <span class=\\"hljs-keyword\\">if</span> (findSign) <span class=\\"hljs-keyword\\">break</span>;\\n    neg = <span class=\\"hljs-literal\\">true</span>;\\n    findSign = <span class=\\"hljs-literal\\">true</span>;\\n}\\n<span class=\\"hljs-keyword\\">else</span> \\n{\\n    <span class=\\"hljs-type\\">int</span> num = (neg ? -(chr - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>) : (chr - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>));\\n    <span class=\\"hljs-keyword\\">if</span> (result &gt; INT_MAX/<span class=\\"hljs-number\\">10</span> || (result == INT_MAX / <span class=\\"hljs-number\\">10</span> &amp;&amp; num &gt; <span class=\\"hljs-number\\">7</span>)) <span class=\\"hljs-keyword\\">return</span> INT_MAX;\\n    <span class=\\"hljs-keyword\\">if</span> (result &lt; INT_MIN/<span class=\\"hljs-number\\">10</span> || (result == INT_MIN / <span class=\\"hljs-number\\">10</span> &amp;&amp; num &lt; <span class=\\"hljs-number\\">-8</span>)) <span class=\\"hljs-keyword\\">return</span> INT_MIN;\\n\\n    findSign = <span class=\\"hljs-literal\\">true</span>;\\n    result *= <span class=\\"hljs-number\\">10</span>;\\n    result = result + num;\\n}\\n</code></pre>\\n<p>부호 문자라면 부호를 결정하고, 숫자라면 수를 계산하여 result 변수에 저장합니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/8/result.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>0ms의 실행 결과가 나왔습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;climits&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">myAtoi</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (!s.<span class=\\"hljs-built_in\\">size</span>()) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> result = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">bool</span> neg = <span class=\\"hljs-literal\\">false</span>;\\n        <span class=\\"hljs-type\\">bool</span> findSign = <span class=\\"hljs-literal\\">false</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = s.<span class=\\"hljs-built_in\\">size</span>() - <span class=\\"hljs-number\\">1</span>; i &gt;= <span class=\\"hljs-number\\">0</span> ; i--)\\n        {\\n            <span class=\\"hljs-type\\">int</span> index = s.<span class=\\"hljs-built_in\\">size</span>() - i - <span class=\\"hljs-number\\">1</span>;\\n            <span class=\\"hljs-type\\">char</span> chr = s[index];\\n\\n            <span class=\\"hljs-keyword\\">if</span> ((chr &lt; <span class=\\"hljs-string\\">&#x27;0&#x27;</span> || chr &gt; <span class=\\"hljs-string\\">&#x27;9&#x27;</span>) &amp;&amp; !((result == <span class=\\"hljs-number\\">0</span>) &amp;&amp; (chr == <span class=\\"hljs-string\\">&#x27;+&#x27;</span> || chr == <span class=\\"hljs-string\\">&#x27;-&#x27;</span>)))\\n            {\\n                <span class=\\"hljs-keyword\\">if</span> (result == <span class=\\"hljs-number\\">0</span> &amp;&amp; !(chr == <span class=\\"hljs-string\\">&#x27;+&#x27;</span> || chr == <span class=\\"hljs-string\\">&#x27;-&#x27;</span> || chr == <span class=\\"hljs-string\\">&#x27; &#x27;</span>)) <span class=\\"hljs-keyword\\">break</span>;\\n                <span class=\\"hljs-keyword\\">if</span> (chr == <span class=\\"hljs-string\\">&#x27;.&#x27;</span>) <span class=\\"hljs-keyword\\">break</span>;\\n\\n                <span class=\\"hljs-keyword\\">if</span> (findSign) <span class=\\"hljs-keyword\\">break</span>;\\n                <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">continue</span>;\\n            }\\n\\n            <span class=\\"hljs-keyword\\">if</span> (chr == <span class=\\"hljs-string\\">&#x27;+&#x27;</span>) \\n            {\\n                <span class=\\"hljs-keyword\\">if</span> (findSign) <span class=\\"hljs-keyword\\">break</span>;\\n                neg = <span class=\\"hljs-literal\\">false</span>;\\n                findSign = <span class=\\"hljs-literal\\">true</span>;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (chr == <span class=\\"hljs-string\\">&#x27;-&#x27;</span>) \\n            {\\n                <span class=\\"hljs-keyword\\">if</span> (findSign) <span class=\\"hljs-keyword\\">break</span>;\\n                neg = <span class=\\"hljs-literal\\">true</span>;\\n                findSign = <span class=\\"hljs-literal\\">true</span>;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span> \\n            {\\n                <span class=\\"hljs-type\\">int</span> num = (neg ? -(chr - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>) : (chr - <span class=\\"hljs-string\\">&#x27;0&#x27;</span>));\\n                <span class=\\"hljs-keyword\\">if</span> (result &gt; INT_MAX/<span class=\\"hljs-number\\">10</span> || (result == INT_MAX / <span class=\\"hljs-number\\">10</span> &amp;&amp; num &gt; <span class=\\"hljs-number\\">7</span>)) <span class=\\"hljs-keyword\\">return</span> INT_MAX;\\n                <span class=\\"hljs-keyword\\">if</span> (result &lt; INT_MIN/<span class=\\"hljs-number\\">10</span> || (result == INT_MIN / <span class=\\"hljs-number\\">10</span> &amp;&amp; num &lt; <span class=\\"hljs-number\\">-8</span>)) <span class=\\"hljs-keyword\\">return</span> INT_MIN;\\n\\n                findSign = <span class=\\"hljs-literal\\">true</span>;\\n                result *= <span class=\\"hljs-number\\">10</span>;\\n                result = result + num;\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},3617:function(s,n,a){"use strict";a.d(n,"c",(function(){return f})),a.d(n,"b",(function(){return O})),a.d(n,"d",(function(){return I})),a.d(n,"a",(function(){return B}));var e=a("7a23"),l=a("ea47"),t=a.n(l),p=Object(e["F"])("data-v-447bff31");Object(e["t"])("data-v-447bff31");var c={class:"header"},r=Object(e["g"])("div",{class:"profile-image"},[Object(e["g"])("img",{src:t.a,alt:"My Profile Image"})],-1),i={class:"title"},o=Object(e["f"])(" Jaehee "),h=Object(e["g"])("p",{class:"description"}," HI! ",-1),d={class:"nav-menu"},j=Object(e["f"])("Home"),u=Object(e["f"])("About"),m=Object(e["g"])("a",{href:"https://github.com/LDobac",target:"_blank",class:"nav-item"},"Github",-1),g=Object(e["g"])("a",{href:"https://www.instagram.com/jaehee24_/",target:"_blank",class:"nav-item"},"Instagram",-1);Object(e["r"])();var b=p((function(s,n,a,l,t,b){var y=Object(e["y"])("router-link");return Object(e["q"])(),Object(e["d"])("header",c,[r,Object(e["g"])("h1",i,[Object(e["g"])(y,{to:"/"},{default:p((function(){return[o]})),_:1}),h]),Object(e["g"])("nav",d,[Object(e["g"])(y,{to:"/",class:"nav-item"},{default:p((function(){return[j]})),_:1}),Object(e["g"])(y,{to:"/about",class:"nav-item"},{default:p((function(){return[u]})),_:1}),m,g])])})),y=Object(e["h"])({name:"Header",setup:function(){}});a("4adc");y.render=b,y.__scopeId="data-v-447bff31";var f=y,w=Object(e["F"])("data-v-3a4c6208");Object(e["t"])("data-v-3a4c6208");var _={class:"footer"};Object(e["r"])();var k=w((function(s,n,a,l,t,p){return Object(e["q"])(),Object(e["d"])("footer",_," Copyright 2021 by Jaehee All rights reserved. ")})),v=Object(e["h"])({name:"Footer"});a("59e6");v.render=k,v.__scopeId="data-v-3a4c6208";var O=v,x=a("e1c4"),L=a.n(x),S=Object(e["F"])("data-v-41258d0c");Object(e["t"])("data-v-41258d0c");var M={class:"side-menu"},N=Object(e["g"])("div",{class:"card"},[Object(e["g"])("p",null,"아직 별 넣을 내용이 없읍니다."),Object(e["g"])("br"),Object(e["g"])("p",null,"귀여운 저희 집 고양이나 봐주세요"),Object(e["g"])("img",{src:L.a})],-1);Object(e["r"])();var z=S((function(s,n,a,l,t,p){return Object(e["q"])(),Object(e["d"])("aside",M,[N])})),A=Object(e["h"])({name:"LeftSideMenu"});a("adc8");A.render=z,A.__scopeId="data-v-41258d0c";var I=A,q=Object(e["F"])("data-v-41965791");Object(e["t"])("data-v-41965791");var C={class:"date"};Object(e["r"])();var F=q((function(s,n,a,l,t,p){return Object(e["q"])(),Object(e["d"])("p",C,"📅 "+Object(e["A"])(s.formattedDate),1)})),P=a("5a0c"),R=a.n(P),T=Object(e["h"])({name:"FormattedDate",props:{date:{type:[String,Object]}},setup:function(s){var n=Object(e["B"])(s),a=n.date,l=Object(e["b"])((function(){return"string"==typeof a.value?R()(a.value).format("YYYY년 MM월 DD일"):a.value.format("YYYY년 MM월 DD일")}));return{formattedDate:l}}});a("b4fe");T.render=F,T.__scopeId="data-v-41965791";var B=T},3715:function(s,n,a){"use strict";a("3d3e")},"3c34":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---10-regular-expression-matching\\">LeetCode - 10. Regular Expression Matching</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/regular-expression-matching/\\">LeetCode 10. Regular Expression Matching</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><img src=\\"https://resources.jetbrains.com/help/img/idea/2021.2/rm_tips_check_reg_exp.png\\" alt=\\"Regular expression example\\"></p>\\n<p>정규 표현식은 주어진 문자열에 대해서 패턴 문자열(정규 표현식)이 주어지면 해당 패턴을 갖는 문자열을 표현하는 방법입니다.</p>\\n<p>이번 문제에서는 Any character를 나타내는 <code>&quot;.&quot;</code> 과 0 또는 하나 이상의 문자 집합을 나타내는 <code>&quot;*&quot;</code> 패턴 문자를 구현하는 문제입니다.</p>\\n<p>난이도는 <code>HARD</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution---dynamic-programming\\">Solution - Dynamic programming</h3>\\n<p>본 문제를 풀기 위해서 동적 프로그래밍 방법을 사용하였습니다.</p>\\n<p>패턴을 찾기 위해서 문자열과 패턴 문자열을 모두 순회하면서 패턴을 찾아야 합니다.</p>\\n<p>여기서 한가지 특성은 만약 패턴 &quot;a*&quot;가 주어졌을 때 부분 패턴 문자열 &quot;a&quot;가 문자열에 매칭될 경우에 참이되며 추가적인 &quot;a&quot;를 찾을 수도 있고, 찾기 못하더라도 참이 되게때문에 여러 분기가 발생하게 됩니다.</p>\\n<p>동적 프로그래밍 방법을 이용해 부분 패턴 문자열을 순회하면서 참인 경우를 따로 저장하여 나중에 똑같은 부분 패턴을 조회할 때 똑같은 검사를 수행하지 않고 저장한 값을 반환하여 성능 향상을 노릴 수 있습니다.</p>\\n<pre><code class=\\"language-c++\\">std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">char</span>&gt;&gt; dp;\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> i, <span class=\\"hljs-type\\">int</span> j, <span class=\\"hljs-keyword\\">const</span> std::string&amp; s ,<span class=\\"hljs-keyword\\">const</span> std::string&amp; p)</span>\\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (dp[i][j] != <span class=\\"hljs-number\\">-1</span>) <span class=\\"hljs-keyword\\">return</span> dp[i][j];\\n\\n    ...\\n\\n    <span class=\\"hljs-keyword\\">return</span> match;\\n}\\n</code></pre>\\n<p>먼저 2차원 배열을 선언합니다. 이 배열이 이전에 계산한 결과를 저장할 것입니다. boolean이 아닌 char 타입으로 한 이유는 아직 i, j 번째를 순회하지 않았을 경우를 따로 나타내기 위해서 모든 값을 -1으로 초기화 하였습니다.</p>\\n<p><code>isMatch</code> 함수는 i, j, 문자열, 패턴 문자열이 주어지는 함수입니다. i는 s의 부분 문자열의 시작 인덱스, j는 부분 패턴 문자열의 시작 인덱스를 나타냅니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">bool</span> firstMatch = (i &lt; s.<span class=\\"hljs-built_in\\">length</span>()) &amp;&amp; (p[j] == s[i] || p[j] == <span class=\\"hljs-string\\">&#x27;.&#x27;</span>);\\n\\n<span class=\\"hljs-comment\\">// if Kleene star, character matches zero or more</span>\\n<span class=\\"hljs-keyword\\">if</span> (j + <span class=\\"hljs-number\\">1</span> &lt; p.<span class=\\"hljs-built_in\\">length</span>() &amp;&amp; p[j + <span class=\\"hljs-number\\">1</span>] == <span class=\\"hljs-string\\">&#x27;*&#x27;</span>)\\n{\\n            <span class=\\"hljs-comment\\">// If zero match, skip Kleene star</span>\\n    match = <span class=\\"hljs-built_in\\">isMatch</span>(i, j + <span class=\\"hljs-number\\">2</span>, s, p) || \\n            <span class=\\"hljs-comment\\">// If non-zero matches, keep finding more matches character</span>\\n            (firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j, s, p));\\n}\\n<span class=\\"hljs-keyword\\">else</span>\\n{\\n    <span class=\\"hljs-comment\\">// Finding next matches character</span>\\n    match = firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j + <span class=\\"hljs-number\\">1</span>, s, p);\\n}\\n</code></pre>\\n<p>매칭을 수행하는 부분만 따로 빼서 자세히 확인해보겠습니다. 먼저 현재 패턴 문자와 입력 문자가 같은지 확인합니다. 만약 패턴 문자가 <code>&#39;.&#39;</code> 이라면 모든 문자와 매칭되니 <code>true</code>가 될 것입니다.</p>\\n<p>만약 0또는 1개 이상의 문자 집합을 매칭하는 <code>&#39;*&#39;</code> 문자는 &quot;a*&quot;와 같이 다른 문자와 함께 붙어서 나오기 때문에 해당 부분에 대해서 확인하고 예외 처리를 진행합니다.</p>\\n<p><code>&#39;*&#39;</code> 문자는 0개 또는 1개 이상의 문자열과 매칭되기 때문에 첫 번째로 0개가 매칭 되었을 경우 <code>isMatch(i, j + 2, s, p)</code>에 대해서 확인합니다. <code>j+2</code>의 의미는 패턴 문자열의 시작 인덱스를 2만큼 증가시키니 <code>&#39;*&#39;</code> 문자 이후의 패턴들을 검사합니다.</p>\\n<p>두 번째로 하나의 문자가 매치되었을 경우(firstMatch) 현재 문자 이후의 문자가 계속 연속적으로 매칭되는지 확인합니다 <code>(firstMatch &amp;&amp; isMatch(i+1, j, s, p))</code></p>\\n<p>만약 <code>&#39;*&#39;</code> 문자가 아니고 문자 매칭이라면 i + 1, j + 1에 대해서 계속 매치를 시도합니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/10/result.png\\" alt=\\"Solution 1 result\\"></p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(std::string s, std::string p)</span> \\n    </span>{\\n        std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">char</span>&gt;&gt; <span class=\\"hljs-built_in\\">tmp</span>(s.<span class=\\"hljs-built_in\\">size</span>() + <span class=\\"hljs-number\\">1</span>, std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">char</span>&gt;(p.<span class=\\"hljs-built_in\\">size</span>() + <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">-1</span>));\\n        dp.<span class=\\"hljs-built_in\\">swap</span>(tmp);\\n\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">isMatch</span>(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>, s, p);\\n    }\\n\\n<span class=\\"hljs-keyword\\">private</span>:\\n    std::vector&lt;std::vector&lt;<span class=\\"hljs-type\\">char</span>&gt;&gt; dp;\\n\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> i, <span class=\\"hljs-type\\">int</span> j, <span class=\\"hljs-keyword\\">const</span> std::string&amp; s ,<span class=\\"hljs-keyword\\">const</span> std::string&amp; p)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (dp[i][j] != <span class=\\"hljs-number\\">-1</span>) <span class=\\"hljs-keyword\\">return</span> dp[i][j];\\n\\n        <span class=\\"hljs-type\\">char</span> match = <span class=\\"hljs-number\\">-1</span>;\\n\\n        <span class=\\"hljs-comment\\">// If no more patterns</span>\\n        <span class=\\"hljs-keyword\\">if</span> (j == p.<span class=\\"hljs-built_in\\">length</span>())\\n        {\\n            <span class=\\"hljs-comment\\">// True when no more string, If string does not empty, False</span>\\n            match = (i == s.<span class=\\"hljs-built_in\\">length</span>());\\n        }\\n        <span class=\\"hljs-keyword\\">else</span> \\n        {\\n            <span class=\\"hljs-type\\">bool</span> firstMatch = (i &lt; s.<span class=\\"hljs-built_in\\">length</span>()) &amp;&amp; (p[j] == s[i] || p[j] == <span class=\\"hljs-string\\">&#x27;.&#x27;</span>);\\n\\n            <span class=\\"hljs-comment\\">// if Kleene star, character matches zero or more</span>\\n            <span class=\\"hljs-keyword\\">if</span> (j + <span class=\\"hljs-number\\">1</span> &lt; p.<span class=\\"hljs-built_in\\">length</span>() &amp;&amp; p[j + <span class=\\"hljs-number\\">1</span>] == <span class=\\"hljs-string\\">&#x27;*&#x27;</span>)\\n            {\\n                        <span class=\\"hljs-comment\\">// If zero match, skip Kleene star</span>\\n                match = <span class=\\"hljs-built_in\\">isMatch</span>(i, j + <span class=\\"hljs-number\\">2</span>, s, p) || \\n                        <span class=\\"hljs-comment\\">// If non-zero matches, keep finding more matches character</span>\\n                        (firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j, s, p));\\n            }\\n            <span class=\\"hljs-comment\\">// </span>\\n            <span class=\\"hljs-keyword\\">else</span>\\n            {\\n                <span class=\\"hljs-comment\\">// Finding next matches character</span>\\n                match = firstMatch &amp;&amp; <span class=\\"hljs-built_in\\">isMatch</span>(i + <span class=\\"hljs-number\\">1</span>, j + <span class=\\"hljs-number\\">1</span>, s, p);\\n            }\\n        }\\n\\n        dp[i][j] = match;\\n\\n        <span class=\\"hljs-keyword\\">return</span> match;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},"3d3e":function(s,n,a){},"3e94":function(s,n,a){s.exports=a.p+"img/귀여운_고양이_2.7dda7633.jpg"},"4adc":function(s,n,a){"use strict";a("67b6")},"4eaf":function(s,n,a){"use strict";a("0e31")},"58a7":function(s,n,a){"use strict";a.d(n,"a",(function(){return c}));var e=a("7a23");function l(s,n,a,l,t,p){var c=Object(e["y"])("LeftSideMenu");return Object(e["q"])(),Object(e["d"])(e["a"],null,[Object(e["g"])(c),Object(e["x"])(s.$slots,"default")],64)}var t=a("3617"),p=Object(e["h"])({name:"ContentWithSideMenuLayout",components:{LeftSideMenu:t["d"]}});p.render=l;var c=p},5938:function(s,n,a){"use strict";a("9c2e")},"59e6":function(s,n,a){"use strict";a("793b")},"5e6b":function(s,n,a){},"5f26":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---7-reverse-integer\\">LeetCode - 7. Reverse Integer</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/reverse-integer/\\">LeetCode 7. Reverse Integer</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>정수 123이 주어진다면 321로, -123이 주어진다면 -321, 1200이 주어진다면 21로 변환하는 문제입니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution\\">Solution</h3>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">while</span> (x != <span class=\\"hljs-number\\">0</span>)\\n{   \\n    <span class=\\"hljs-keyword\\">if</span> (result &gt; (INT_MAX / <span class=\\"hljs-number\\">10</span>)) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (result &lt; (INT_MIN / <span class=\\"hljs-number\\">10</span>)) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n\\n    result *= <span class=\\"hljs-number\\">10</span>;\\n    result += (x % <span class=\\"hljs-number\\">10</span>);\\n\\n    x /= <span class=\\"hljs-number\\">10</span>;\\n}\\n</code></pre>\\n<p>단순히 입력 값 x의 나머지를 result에 더하고 다음 순회시 result에 10을 곱하여 변환하는 방식을 사용했습니다.</p>\\n<p>입력값은 <code>int</code> 타입이므로 32bit 크기의 자료형이기 때문에 만약 입력값이 뒤집었을 때 <code>int</code> 자료형의 크기가 넘을 경우 0을 반환하는 예외 처리를 수행합니다.</p>\\n<p>이번 문제에서는 <code>INT_MAX</code>의 값을 이용해 <code>int</code> 타입의 범위를 검사하였지만, <code>long</code>과 같이 <code>int</code>타입보다 더 큰 자료형을 이용한다면 별도의 예외 처리가 필요하지 않습니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/7/result.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>0ms의 실행결과가 나왔으며, 다른 C++ 제출자에 비해 100% 좋은 성능이 보임을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;cmath&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;climits&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">reverse</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> x)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (x == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> x;\\n\\n        <span class=\\"hljs-type\\">int</span> result = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span> (x != <span class=\\"hljs-number\\">0</span>)\\n        {   \\n            <span class=\\"hljs-keyword\\">if</span> (result &gt; (INT_MAX / <span class=\\"hljs-number\\">10</span>)) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n            <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (result &lt; (INT_MIN / <span class=\\"hljs-number\\">10</span>)) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n\\n            result *= <span class=\\"hljs-number\\">10</span>;\\n            result += (x % <span class=\\"hljs-number\\">10</span>);\\n\\n            x /= <span class=\\"hljs-number\\">10</span>;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},6683:function(s,n,a){},"67b6":function(s,n,a){},"6bc8":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---3-longest-substring-without-repeating-characters\\">LeetCode - 3. Longest Substring Without Repeating Characters</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\\">LeetCode 3. Longest Substring Without Repeating Characters</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>특정 문자열 <code>s</code>가 주어질 때 똑같은 문자를 반복하지 않는, 가장 긴 부분 문자열을 구하는 문제입니다.</p>\\n<p><img src=\\"/assets/images/leet_code/3/exam.png\\" alt=\\"Problem Example\\"></p>\\n<p>만약 입력 문자열이 <code>s = &quot;abcabcbb&quot;</code>라면 반복하는 bb를 제외하고, 반복하지 않는 문자열인 &quot;abc&quot;의 길이인 3이 구해집니다.</p>\\n<p>즉, 부분 문자열에서 동일한 문자가 없는, 가장 긴 길이의 부분 문자열을 구합니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>첫 번째 시도는 무차별 대입을 통한 검사를 진행합니다.</p>\\n<p>만약 s 문자열의 길이가 n이라면 i가 0-&gt;n 일때 i ~ n사이의 부분 문자열을 계속 찾습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n</span>{\\n    <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n    {\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> sliceStart = i;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n        {\\n            std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(sliceStart, length);\\n            <span class=\\"hljs-type\\">int</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(j));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (pos == std::string::npos)\\n            {\\n                <span class=\\"hljs-comment\\">// Not found</span>\\n                length++;\\n\\n                longestLength = (longestLength &lt; length) ? length : longestLength;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span>\\n            {\\n                <span class=\\"hljs-keyword\\">break</span>;\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() - i &lt; longestLength) <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> longestLength;\\n}\\n</code></pre>\\n<p>중첩된 반복문을 이용해 모든 경우의 수를 탐색합니다.</p>\\n<p>문자열을 찾는 주요 부분은 내부 반복문이니 내부 반복문만 따로 빼서 확인해보겠습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n{\\n    std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(sliceStart, length);\\n    <span class=\\"hljs-type\\">int</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(j));\\n\\n    <span class=\\"hljs-keyword\\">if</span> (pos == std::string::npos)\\n    {\\n        <span class=\\"hljs-comment\\">// Not found</span>\\n        length++;\\n\\n        longestLength = (longestLength &lt; length) ? length : longestLength;\\n    }\\n    <span class=\\"hljs-keyword\\">else</span>\\n    {\\n        <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n}\\n</code></pre>\\n<p>j는 i -&gt; n까지 증가합니다. 문자열 s를 i부터 length 길이만큼 잘라 부분 문자열을 생성합니다. 문자열 s의 j번째 문자를 가져와 현재 부분 문자열에 동일한 문자가 있는지 검사합니다.</p>\\n<p>만약 현재 추출한 부분 문자열에 동일한 문자(중복되는 문자)가 없다면 부분 문자열의 길이를 1 증가합니다.</p>\\n<p>중복된 문자열이 존재하다면 반복문을 탈출합니다.</p>\\n<p>위 반복문을 s문자열의 길이 n번만큼 반복합니다. 즉, O(n^2)의 알고리즘이 됩니다. 추가로 이 코드에서는 문자열을 탐색할 때 라이브러리의 함수를 사용하였지만, 선형 탐색을 통하여 문자열을 탐색한다면 O(n^3)의 알고리즘이 될 수도 있습니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/3/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행 시간은 628ms, 메모리 사용량은 273.1MB가 나오게 되었습니다. 동일한 C++ 제출자에 비해서 8.92% 정도밖에 빠르지 않은 매우 느린 코드임을 알 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n        {\\n            <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n            <span class=\\"hljs-type\\">int</span> sliceStart = i;\\n\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n            {\\n                std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(sliceStart, length);\\n                <span class=\\"hljs-type\\">int</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(j));\\n\\n                <span class=\\"hljs-keyword\\">if</span> (pos == std::string::npos)\\n                {\\n                    <span class=\\"hljs-comment\\">// Not found</span>\\n                    length++;\\n\\n                    longestLength = (longestLength &lt; length) ? length : longestLength;\\n                }\\n                <span class=\\"hljs-keyword\\">else</span>\\n                {\\n                    <span class=\\"hljs-keyword\\">break</span>;\\n                }\\n            }\\n\\n            <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() - i &lt; longestLength) <span class=\\"hljs-keyword\\">break</span>;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> longestLength;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2---sliding-window\\">Solution 2 - Sliding window</h3>\\n<p>첫 번째 방법의 문제점은 중첩된 반복문을 순회하면서 이미 검사한 문자열을 또 다시 검사하기 때문에 좋은 속도가 나지 않았습니다.</p>\\n<p>아이디어를 살짝 바꾸어서 생각해보겠습니다. 문자열 <code>s = &quot;abcabcbb&quot;</code>가 주어질 때 여기서 중복되지 않는 문자들의 집합인 부분 문자열의 길이가 가장 긴 것을 구하는 것입니다.</p>\\n<p>때문에 부분 문자열이 &quot;abc&quot;이든 &quot;bca&quot;이든 조건을 만족하면서 가장 긴 부분 문자열이 되게 됩니다.</p>\\n<p>문자열을 검사하면서 &quot;abc&quot;에서 &quot;abca&quot;가 되었다면 이때 문자 &quot;a&quot;가 겹치게 되므로 이 문자열은 정답이 될 수 없습니다. 하지만 &quot;abca&quot;를 다시 조건에 맞는 문자열로 바꾸는 방법은 맨 뒤의 &quot;a&quot;를 제거할 수도 있지만, 반대로 맨 처음의 &quot;a&quot;를 제거할 수도 있습니다.</p>\\n<p>즉, &quot;abca&quot; -&gt; &quot;bca&quot;로 변환한다면 조건에 만족하는 문자열이 되게 됩니다. 이때 왼쪽의 index를 <code>left</code>, 오른쪽의 index를 <code>right</code>라 한다면 <code>left</code>를 1 증가시키기만 하면 반복문을 처음부터 순회할 필요 없이 정답에 맞는 조건이 되게 됩니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n    {\\n        std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(left, length);\\n        <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n        <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n        {\\n            left += (pos + <span class=\\"hljs-number\\">1</span>);\\n        }\\n        \\n        right++;\\n        length = right - left;\\n\\n        longestLength = (longestLength &lt; length) ? length : longestLength;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> longestLength;\\n}\\n</code></pre>\\n<p>sliding window를 구성하는 left, right 변수를 추가하여 매 순회시 마다 right 즉, window를 늘려갑니다.</p>\\n<p>만약 중복되는 문자열이 부분 문자열 내에 있다면 해당 index(pos)만큼 더하여 window를 줄입니다(sliding).</p>\\n<p>오히려 코드가 훨씬 간단해지고 루프문도 하나로 줄었으니 O(n)정도의 성능을 기대할 수 있을 것 같습니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/3/result_2.png\\" alt=\\"Solution 2 result\\"></p>\\n<p>코드의 실행 속도는 16ms로 향상되었으며 사용 메모리도 11.6MB로 크게 향상되었습니다. 다른 C++ 제출자에 비해서 66.67%의 빠른 성능을 보여줌을 확인할 수 있었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n        {\\n            std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(left, length);\\n            <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n            {\\n                left += (pos + <span class=\\"hljs-number\\">1</span>);\\n            }\\n            \\n            right++;\\n            length = right - left;\\n\\n            longestLength = (longestLength &lt; length) ? length : longestLength;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> longestLength;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-3---sliding-window-optimized-stdstring\\">Solution 3 - sliding window optimized std::string</h3>\\n<p>2 번째 방법의 경우 <strong>std::string</strong>의 부분 문자열을 구하는 함수인 <strong>substr</strong> 함수를 이용했습니다.</p>\\n<pre><code class=\\"language-c++\\">std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(left, length);\\n<span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n</code></pre>\\n<p>위 함수가 현재 상황에서 발생하는 문제점은 <strong>substr</strong>함수는 문자열을 자른 후 새로운 std::string 객체를 생성하여 반환하게 됩니다. 즉 문자열을 자른 후 메모리를 할당하는 과정이 생기기에 overhead가 발생합니다.</p>\\n<p>이러한 문제를 해결하기 위해서 C++ 17부터는 <a href=\\"https://en.cppreference.com/w/cpp/string/basic_string_view\\">std::string_view</a>라는 객체가 도입되었습니다.</p>\\n<p><strong>std::string_view</strong> 객체는 기본적으로 char*의 포인터와 문자열의 길이(size)만 가지는 문자열 객체이며 사실상 char* 타입에 간단한 부분 문자열, 문자열 찾기와 같은 함수만 추가한 객체입니다.</p>\\n<p>객체의 생성, 탐색과 같은 부분이 최소 O(1)에서 O(n)내의 연산으로 이루어져있기 때문에 문자열을 이용해 복잡한 연산이나 변형을 하지 않고 탐색만 한다면 매우 적절한 클래스입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n    {\\n        <span class=\\"hljs-comment\\">// std::string -&gt; std::string_view</span>\\n        <span class=\\"hljs-function\\">std::string_view <span class=\\"hljs-title\\">substr</span><span class=\\"hljs-params\\">(&amp;s[left], length)</span></span>;\\n        <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n        <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n        {\\n            left += (pos + <span class=\\"hljs-number\\">1</span>);\\n        }\\n        \\n        right++;\\n        length = right - left;\\n\\n        longestLength = (longestLength &lt; length) ? length : longestLength;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> longestLength;\\n}\\n</code></pre>\\n<p>유일하게 변경된 점은 <strong>std::string</strong> -&gt; <strong>std::string_view</strong>로만 변경되었습니다. 다행히 <strong>std::string_view</strong>클래스도 substr을 지원하기 때문에 간단히 사용 가능합니다.</p>\\n<h4 id=\\"제출-결과-2\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/3/result_3.png\\" alt=\\"Solution 3 result\\"></p>\\n<p>실행 시간은 4ms, 메모리는 6.7MB로 다른 방법에 비해서 속도와 메모리가 월등히 향상되었습니다.</p>\\n<p>다른 C++ 제출자에 비해서 96%나 빠른 성능을 보여줌을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string_view&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n        {\\n            <span class=\\"hljs-function\\">std::string_view <span class=\\"hljs-title\\">substr</span><span class=\\"hljs-params\\">(&amp;s[left], length)</span></span>;\\n            <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n            {\\n                left += (pos + <span class=\\"hljs-number\\">1</span>);\\n            }\\n            \\n            right++;\\n            length = right - left;\\n\\n            longestLength = (longestLength &lt; length) ? length : longestLength;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> longestLength;\\n    }\\n};\\n</code></pre>\\n</details>"}')},7851:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---4-median-of-two-sorted-arrays\\">LeetCode - 4. Median of Two Sorted Arrays</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/add-two-numbers/\\">LeetCode 4. Add Two Numbers</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>정수 값이 담겨있으며 정렬된 두 배열이 넘어올 때 두 배열의 중앙값(Median)을 계산하는 문제입니다.</p>\\n<p><img src=\\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Finding_the_median.png/640px-Finding_the_median.png\\" alt=\\"Median\\"></p>\\n<p><a href=\\"https://ko.wikipedia.org/wiki/%EC%A4%91%EC%95%99%EA%B0%92\\">중앙값</a>은 정렬될 수의 배열 중 중앙에 위치하는 값을 말합니다. 수의 개수가 홀수라면 하나가 선택될 것이고, 짝수라면 두 수를 골라 평균을 계산하여 중앙값을 구할 수 있습니다.</p>\\n<p><img src=\\"/assets/images/leet_code/4/example.png\\" alt=\\"input example\\"></p>\\n<p>만약 위 이미지와 같이 2개의 정렬된 정수 배열이 전달된다면 두 배열의 수를 나란히 나열하면 1, 1, 2, 3, 10, 10, 20, 45, 55, 70으로 나열할 수 있으며 10, 10이 중간값으로 선택되니 (10+10)/2 = 10, 즉 최종적으로 10이 중간값이 될 것입니다.</p>\\n<p>난이도는 <code>HARD</code> 난이도 입니다.</p>\\n<p><a href=\\"https://youtu.be/q6IEA26hvXc\\">Reference Video</a></p>\\n<p>본 문제를 해결하기 위해 위 영상의 설명의 도움을 받았습니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution\\">Solution</h3>\\n<p>중간값을 구하기 먼저 문제에 제한사항이 있었습니다.</p>\\n<p><img src=\\"/assets/images/leet_code/4/limit.png\\" alt=\\"Limit\\"></p>\\n<p>소스 코드의 시간 복잡도는 O(log(m+n))(m, n은 배열)이 넘지 않아야 합니다. 이로 인해 두 배열을 하나로 합쳐 중간값을 구할 수 없습니다.</p>\\n<p>두 배열을 하나로 합치기 위해서는 m, n을 순회해야 하므로 O(m+n)의 시간 복잡도가 발생하는데 이는 O(m+n) &gt; O(log(m+n))이므로 배열을 합치지 않고 찾아야 합니다.</p>\\n<p>이를 해결하기 위해 생각한 방법은 이진 탐색과 비슷한 논리를 이용하는 방법을 떠올렸습니다.</p>\\n<p>이진 탐색을 수행하기 위해서는 배열이 정렬되어있어야 하고, 맨 처음 중간 값을 골랐을 때 정렬된 배열이라면 중간 값의 왼쪽 값은 당연히 중간 값 보다 작거나 같아야하고, 우측 값은 무조건 중간 값보다 크거나 같아야 합니다.</p>\\n<p><img src=\\"/assets/images/leet_code/4/middle_1.png\\" alt=\\"median example\\"></p>\\n<p>두 번째 특성은 중간값을 선택하면 중간 값보다 작은 값의 개수와 큰 값의 개수가 동일하다는 것입니다.</p>\\n<p>이러한 특성을 이용해 두 배열을 합치지 않고 중앙값을 구할 수 있습니다.</p>\\n<p><strong>배열의 적절한 Left, Middle, Right 범위 구하기</strong></p>\\n<p>맨 처음으로 배열의 중앙값을 구하기 위해서 중앙값을 골랐을 때 작은 값과 큰 값의 개수가 같음을 이용해 적절한 Left(작은 값의 범위), Middle(중앙값), Right(큰 값의 범위)를 구합니다.</p>\\n<p><img src=\\"/assets/images/leet_code/4/middle_2.png\\" alt=\\"median example 2\\"></p>\\n<p>두 배열의 길이는 10이기에 두 배열이 하나라고 생각할 때 5, 5로 두 개로 분리할 수 있을 것입니다. 이때 중앙값을 기준으로 Left에 위치한 5개 값, Right에 위치한 5개 값입니다.</p>\\n<p>먼저 A 배열의 중앙값(A_left)을 선택합니다. 위 그림에서는 3번째가 선택되었으며 Left에 위치한 값 5개를 채우기 위해 B 배열에서 2번째를 선택해 B의 중앙값(B_left)를 선택합니다. 총 5개의 Left가 선택되었으며 나머지 5개를 자동으로 Left보다 큰 값, Right로 선택합니다.</p>\\n<p>이제 Left, Right나눈 결과가 적절한지 확인합니다, Left의 값들은 무조건 Right의 값보다 작아야 합니다.</p>\\n<p>1, 1, 1, 2, 3 &lt;-Left  Right-&gt; 2, 10, 45, 55, 70</p>\\n<p>Left에 3이라는 값이 있지만 Right에 3보다 작은 2가 분류되어있어 지금 선택된 Left와 Right는 적절하지 않음을 알 수 있습니다. </p>\\n<p><img src=\\"/assets/images/leet_code/4/middle_4.png\\" alt=\\"median example 4\\"></p>\\n<p>단순하게 사람의 눈으로 보면 바로 구분이 되지만, 이를 확실하게 구분하는 방법은 A_left(A의 중앙값)은 B_left+1(B의 중앙값의 다음 값)보다 작아야합니다. 반대의 경우도 B_left &lt;= A_left+1이여야 합니다.</p>\\n<p>이를 해결하기 위해 A의 중앙값 index를 1 감소시키고, B의 중앙값을 1 증가시킵니다.</p>\\n<p><img src=\\"/assets/images/leet_code/4/middle_3.png\\" alt=\\"median example 3\\"></p>\\n<p>다시 적절한 분류인지 확인합니다.</p>\\n<p>1, 1, 1, 2, 2 &lt;-Left  Right-&gt; 3, 10, 45, 55, 70</p>\\n<p>다시 확인해보니 적절하게 분류되었습니다. 이제 중앙값을 선택해야하는데, 위 처럼 정리하는것은 편의상 일렬로 나란히 정렬한것이지만, 실제로는 두 배열의 index를 각각 가지고 있기 때문에 적절하게 선택할 방법이 필요합니다.</p>\\n<p>이는 간단하게 수행할 수 있습니다. Left로 분류된 값 중 가장 큰 값이 중앙값일것이며 Right로 분류된 값 중 가장 작은 값이 중앙값일것입니다.</p>\\n<p>즉 <code>(max(A_left, B_left) + max(A_right, B_right))/2</code>가 중앙값이 될 것입니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/4/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행시간은 20ms로 다른 C++ 제출자에 비해 96%가량 좋은 성능을 보이는 코드를 작성할 수 있었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;algorithm&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;limits&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">double</span> <span class=\\"hljs-title\\">findMedianSortedArrays</span><span class=\\"hljs-params\\">(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums1, std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums2)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (nums1.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span> &amp;&amp; nums2.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>)\\n        {\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0.0</span>;\\n        }\\n\\n        <span class=\\"hljs-type\\">int</span> totalLength = nums1.<span class=\\"hljs-built_in\\">size</span>() + nums2.<span class=\\"hljs-built_in\\">size</span>();\\n        <span class=\\"hljs-type\\">int</span> half = totalLength / <span class=\\"hljs-number\\">2</span>;\\n        \\n        std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; A = nums1;\\n        std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; B = nums2;\\n\\n        <span class=\\"hljs-keyword\\">if</span> (nums1.<span class=\\"hljs-built_in\\">size</span>() &lt; nums2.<span class=\\"hljs-built_in\\">size</span>())\\n        {\\n            <span class=\\"hljs-keyword\\">auto</span> tmp = A;\\n            A = nums2;\\n            B = tmp;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">if</span> (A.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>)\\n        {\\n            <span class=\\"hljs-type\\">int</span> mid = B.<span class=\\"hljs-built_in\\">size</span>() / <span class=\\"hljs-number\\">2</span>;\\n            <span class=\\"hljs-keyword\\">if</span> ((B.<span class=\\"hljs-built_in\\">size</span>() % <span class=\\"hljs-number\\">2</span>) == <span class=\\"hljs-number\\">0</span>)\\n            {\\n                <span class=\\"hljs-keyword\\">return</span> (B[mid - <span class=\\"hljs-number\\">1</span>] + B[mid]) / <span class=\\"hljs-number\\">2.0</span>;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span>\\n            {\\n                <span class=\\"hljs-built_in\\">return</span> (<span class=\\"hljs-type\\">double</span>)B[mid];\\n            }\\n        }\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (B.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>)\\n        {\\n            <span class=\\"hljs-type\\">int</span> mid = A.<span class=\\"hljs-built_in\\">size</span>() / <span class=\\"hljs-number\\">2</span>;\\n            <span class=\\"hljs-keyword\\">if</span> ((A.<span class=\\"hljs-built_in\\">size</span>() % <span class=\\"hljs-number\\">2</span>) == <span class=\\"hljs-number\\">0</span>)\\n            {\\n                <span class=\\"hljs-keyword\\">return</span> (A[mid - <span class=\\"hljs-number\\">1</span>] + A[mid]) / <span class=\\"hljs-number\\">2.0</span>;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span>\\n            {\\n                <span class=\\"hljs-built_in\\">return</span> (<span class=\\"hljs-type\\">double</span>)A[mid];\\n            }\\n        }\\n\\n        <span class=\\"hljs-type\\">int</span> l = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> r = A.<span class=\\"hljs-built_in\\">size</span>() - <span class=\\"hljs-number\\">1</span>;\\n\\n        <span class=\\"hljs-keyword\\">do</span> \\n        {\\n            <span class=\\"hljs-type\\">int</span> aLeftMidIndex = (l + r) /<span class=\\"hljs-number\\">2</span>;\\n            <span class=\\"hljs-type\\">int</span> bLeftMidIndex = half - aLeftMidIndex - <span class=\\"hljs-number\\">2</span>;\\n\\n            <span class=\\"hljs-type\\">int</span> aLeft = aLeftMidIndex &gt;= <span class=\\"hljs-number\\">0</span> ? A[aLeftMidIndex] : std::numeric_limits&lt;<span class=\\"hljs-type\\">int</span>&gt;::<span class=\\"hljs-built_in\\">min</span>();\\n            <span class=\\"hljs-type\\">int</span> aRight = (aLeftMidIndex + <span class=\\"hljs-number\\">1</span>) &lt; A.<span class=\\"hljs-built_in\\">size</span>() ? A[(aLeftMidIndex + <span class=\\"hljs-number\\">1</span>)] : std::numeric_limits&lt;<span class=\\"hljs-type\\">int</span>&gt;::<span class=\\"hljs-built_in\\">max</span>();\\n            <span class=\\"hljs-type\\">int</span> bLeft = bLeftMidIndex &gt;= <span class=\\"hljs-number\\">0</span> ? B[bLeftMidIndex] : std::numeric_limits&lt;<span class=\\"hljs-type\\">int</span>&gt;::<span class=\\"hljs-built_in\\">min</span>();\\n            <span class=\\"hljs-type\\">int</span> bRight = (bLeftMidIndex + <span class=\\"hljs-number\\">1</span>) &lt; B.<span class=\\"hljs-built_in\\">size</span>() ? B[(bLeftMidIndex + <span class=\\"hljs-number\\">1</span>)] : std::numeric_limits&lt;<span class=\\"hljs-type\\">int</span>&gt;::<span class=\\"hljs-built_in\\">max</span>();\\n\\n            <span class=\\"hljs-keyword\\">if</span> (aLeft &lt;= bRight &amp;&amp; bLeft &lt;= aRight)\\n            {\\n                <span class=\\"hljs-keyword\\">if</span> ((totalLength % <span class=\\"hljs-number\\">2</span>) == <span class=\\"hljs-number\\">0</span>)\\n                {\\n                    <span class=\\"hljs-keyword\\">return</span> (std::<span class=\\"hljs-built_in\\">max</span>(aLeft, bLeft) + std::<span class=\\"hljs-built_in\\">min</span>(aRight, bRight)) / <span class=\\"hljs-number\\">2.0</span>;\\n                }\\n                <span class=\\"hljs-keyword\\">else</span>\\n                {\\n                    <span class=\\"hljs-built_in\\">return</span> (<span class=\\"hljs-type\\">double</span>)std::<span class=\\"hljs-built_in\\">min</span>(aRight, bRight);\\n                }\\n            }\\n            <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (aLeft &gt; bRight)\\n            {\\n                r--;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (bLeft &gt; aRight)\\n            {\\n                r++;\\n            }\\n        } <span class=\\"hljs-keyword\\">while</span>(<span class=\\"hljs-literal\\">true</span>);\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},"793b":function(s,n,a){},"7e73":function(s,n,a){"use strict";a.d(n,"c",(function(){return r})),a.d(n,"a",(function(){return j})),a.d(n,"b",(function(){return k}));a("b0c0");var e=a("7a23"),l=Object(e["F"])("data-v-61c7223c");Object(e["t"])("data-v-61c7223c");var t={class:"tags-wrap"};Object(e["r"])();var p=l((function(s,n,a,p,c,r){var i=Object(e["y"])("router-link");return Object(e["q"])(),Object(e["d"])("div",t,[(Object(e["q"])(!0),Object(e["d"])(e["a"],null,Object(e["w"])(s.tags,(function(s){return Object(e["q"])(),Object(e["d"])(i,{class:"rounded-button tag",key:s.id,to:{path:"/",query:{tag:s.id}}},{default:l((function(){return[Object(e["f"])(" # "+Object(e["A"])(s.name),1)]})),_:2},1032,["to"])})),128))])})),c=Object(e["h"])({name:"TagsView",props:{tags:{type:Object}},setup:function(){var s=function(s){console.log(s)};return{onButtonClick:s}}});a("5938");c.render=p,c.__scopeId="data-v-61c7223c";var r=c,i=Object(e["F"])("data-v-52d68690");Object(e["t"])("data-v-52d68690");var o={key:0,class:"series-wrap"};Object(e["r"])();var h=i((function(s,n,a,l,t,p){var c=Object(e["y"])("router-link");return s.series?(Object(e["q"])(),Object(e["d"])("span",o,[Object(e["g"])(c,{class:"series",to:{path:"/",query:{series:s.series.id}}},{default:i((function(){return[Object(e["f"])(Object(e["A"])(s.series.name),1)]})),_:1},8,["to"])])):Object(e["e"])("",!0)})),d=Object(e["h"])({props:{series:{type:Object}}});a("2b22");d.render=h,d.__scopeId="data-v-52d68690";var j=d,u=Object(e["F"])("data-v-d6aa614c");Object(e["t"])("data-v-d6aa614c");var m={class:"series-navigator"},g=Object(e["g"])("p",{class:"bold"},"이전",-1),b={key:1},y=Object(e["g"])("p",{class:"bold"},"다음",-1),f={key:3};Object(e["r"])();var w=u((function(s,n,a,l,t,p){var c=Object(e["y"])("router-link");return Object(e["q"])(),Object(e["d"])("div",m,[s.siblingSeriesPost.prev.id?(Object(e["q"])(),Object(e["d"])(c,{key:0,class:"prev-button series-button",to:{name:"PostView",params:{id:s.siblingSeriesPost.prev.id}}},{default:u((function(){return[g,Object(e["f"])(" "+Object(e["A"])(s.siblingSeriesPost.prev.title),1)]})),_:1},8,["to"])):(Object(e["q"])(),Object(e["d"])("div",b)),s.siblingSeriesPost.next.id?(Object(e["q"])(),Object(e["d"])(c,{key:2,class:"next-button series-button",to:{name:"PostView",params:{id:s.siblingSeriesPost.next.id}}},{default:u((function(){return[y,Object(e["f"])(" "+Object(e["A"])(s.siblingSeriesPost.next.title),1)]})),_:1},8,["to"])):(Object(e["q"])(),Object(e["d"])("div",f))])})),_=Object(e["h"])({props:{siblingSeriesPost:Object}});a("ecef");_.render=w,_.__scopeId="data-v-d6aa614c";var k=_},"83f9":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---2-add-two-numbers\\">LeetCode - 2. Add Two Numbers</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/add-two-numbers/\\">LeetCode 2. Add Two Numbers</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>두 개의 LinkedList가 주어지며, LinkedList는 음수가 아닌 한 자리의 숫자를 저장하는 Node들을 가지며, 해당 숫자들의 역순으로 음수가 아닌 하나의 정수를 표현합니다.\\n<img src=\\"https:/assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\\" alt=\\"LinkedList Example\\"></p>\\n<p>위 예시의 경우 <code>2-&gt;4-&gt;3</code>으로 저장되는 LinkedList는 <code>342</code>라는 숫자를 표현합니다.</p>\\n<p>동일하게 밑에 있는 <code>5-&gt;6-&gt;4</code>는 <code>465</code>라는 숫자를 표현하게 됩니다. 이때 두 수를 더하여 807이라는 값을 계산한 후 이를 <code>7-&gt;0-&gt;8</code>로 표현되는 LinkedList로 반환하면 됩니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution\\">Solution</h3>\\n<p>첫 번째 생각했던 방법은 두 LinkedList에 저장된 숫자들을 각각 완성된 정수값으로 변환하여 덧셈 후 다시 LinkedList 형태로 변환하는 방법입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> multiplier = <span class=\\"hljs-number\\">0</span>;\\n<span class=\\"hljs-type\\">int</span> numOfl1 = <span class=\\"hljs-number\\">0</span>;\\n<span class=\\"hljs-type\\">int</span> numOfl2 = <span class=\\"hljs-number\\">0</span>;\\n\\n<span class=\\"hljs-keyword\\">for</span> (ListNode* node = l1; node != <span class=\\"hljs-literal\\">nullptr</span> ; node = node-&gt;next)\\n{\\n    numOfl1 += node-&gt;val * <span class=\\"hljs-built_in\\">powl</span>(<span class=\\"hljs-number\\">10</span>, multiplier);\\n    multiplier++;\\n}\\n\\nmultiplier = <span class=\\"hljs-number\\">0</span>;\\n\\n<span class=\\"hljs-keyword\\">for</span> (ListNode* node = l2; node != <span class=\\"hljs-literal\\">nullptr</span> ; node = node-&gt;next)\\n{\\n    numOfl2 += node-&gt;val * <span class=\\"hljs-built_in\\">powl</span>(<span class=\\"hljs-number\\">10</span>, multiplier);\\n    multiplier++;\\n}\\n\\n<span class=\\"hljs-type\\">int</span> add = numOfl1 + numOfl2;\\n\\nListNode* head = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">ListNode</span>(add % <span class=\\"hljs-number\\">10</span>);\\nListNode* result = head;\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> num = add/<span class=\\"hljs-number\\">10</span>; num &gt; <span class=\\"hljs-number\\">0</span> ; num /= <span class=\\"hljs-number\\">10</span> )\\n{\\n    <span class=\\"hljs-type\\">int</span> digit = num % <span class=\\"hljs-number\\">10</span>;\\n\\n    ListNode* node = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">ListNode</span>(digit);\\n    result-&gt;next = node;\\n\\n    result = node;\\n}\\n\\n<span class=\\"hljs-keyword\\">return</span> head;\\n</code></pre>\\n<p>각각 완성된 정수로 변환 후 덧셈하여 다시 LinkedList로 변환하는 방법이지만, 큰 문제가 하나 발생하하였습니다.</p>\\n<p><img src=\\"/assets/images/leet_code/2.add_two_number/overflow.png\\" alt=\\"overflow\\"></p>\\n<p>코드의 실행 결과 int형의 범위를 넘는 값이 입력된 경우 overflow가 발생해 음수가 되며 Runtime Error가 발생하였습니다.</p>\\n<p>이를 해결하기 위해 두 번째 방법을 사용하였습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> carry = <span class=\\"hljs-number\\">0</span>;\\n\\nListNode* node1 = l1;\\nListNode* node2 = l2;\\n\\nListNode* head = <span class=\\"hljs-literal\\">nullptr</span>;\\nListNode* lastNode = <span class=\\"hljs-literal\\">nullptr</span>;\\n\\n<span class=\\"hljs-keyword\\">while</span> (node1 != <span class=\\"hljs-literal\\">nullptr</span> || node2 != <span class=\\"hljs-literal\\">nullptr</span>)\\n{\\n    <span class=\\"hljs-type\\">int</span> numOf1 = node1 ? node1-&gt;val : <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> numOf2 = node2 ? node2-&gt;val : <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> sum = numOf1 + numOf2 + carry;\\n\\n    carry = sum / <span class=\\"hljs-number\\">10</span>;\\n\\n    ListNode* newNode = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">ListNode</span>(sum % <span class=\\"hljs-number\\">10</span>);\\n\\n    <span class=\\"hljs-keyword\\">if</span> (!head) head = newNode;\\n    <span class=\\"hljs-keyword\\">else</span> lastNode-&gt;next = newNode;\\n\\n    lastNode = newNode;\\n\\n    <span class=\\"hljs-keyword\\">if</span>(node1) node1 = node1-&gt;next;\\n    <span class=\\"hljs-keyword\\">if</span>(node2) node2 = node2-&gt;next;\\n}\\n\\n<span class=\\"hljs-keyword\\">if</span> (carry &gt; <span class=\\"hljs-number\\">0</span>)\\n{\\n    ListNode* node = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">ListNode</span>(carry);\\n    lastNode-&gt;next = node;\\n}\\n</code></pre>\\n<p>int 타입 대신 long, long long과 같은 64bit 타입을 쓴다면 당장의 문제는 해결될지 모르지만, 만약 더 큰 수가 들어온다면 동일한 에러가 발생할 것이 분명합니다.</p>\\n<p>생각을 바꾸어 완성된 정수 값으로 변환하고 더하는 것이 아닌, 한 자리씩 더하여 Node를 생성하고 LinkedList를 형성하면 됩니다.</p>\\n<p>여기서 추가로 신경써주어야 할 부분은 한 자리씩 더한 후에 발생하는 올림(carry)의 경우만 따로 저장해서 다음 자리 수를 더할 때 추가로 더해주면 됩니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">ListNode* <span class=\\"hljs-title\\">addTwoNumbers</span><span class=\\"hljs-params\\">(ListNode* l1, ListNode* l2)</span> \\n    </span>{\\n        <span class=\\"hljs-type\\">int</span> carry = <span class=\\"hljs-number\\">0</span>;\\n\\n        ListNode* node1 = l1;\\n        ListNode* node2 = l2;\\n\\n        ListNode* head = <span class=\\"hljs-literal\\">nullptr</span>;\\n        ListNode* lastNode = <span class=\\"hljs-literal\\">nullptr</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span> (node1 != <span class=\\"hljs-literal\\">nullptr</span> || node2 != <span class=\\"hljs-literal\\">nullptr</span>)\\n        {\\n            <span class=\\"hljs-type\\">int</span> numOf1 = node1 ? node1-&gt;val : <span class=\\"hljs-number\\">0</span>;\\n            <span class=\\"hljs-type\\">int</span> numOf2 = node2 ? node2-&gt;val : <span class=\\"hljs-number\\">0</span>;\\n\\n            <span class=\\"hljs-type\\">int</span> sum = numOf1 + numOf2 + carry;\\n\\n            carry = sum / <span class=\\"hljs-number\\">10</span>;\\n\\n            ListNode* newNode = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">ListNode</span>(sum % <span class=\\"hljs-number\\">10</span>);\\n\\n            <span class=\\"hljs-keyword\\">if</span> (!head) head = newNode;\\n            <span class=\\"hljs-keyword\\">else</span> lastNode-&gt;next = newNode;\\n\\n            lastNode = newNode;\\n\\n            <span class=\\"hljs-keyword\\">if</span>(node1) node1 = node1-&gt;next;\\n            <span class=\\"hljs-keyword\\">if</span>(node2) node2 = node2-&gt;next;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">if</span> (carry &gt; <span class=\\"hljs-number\\">0</span>)\\n        {\\n            ListNode* node = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">ListNode</span>(carry);\\n            lastNode-&gt;next = node;\\n        }\\n    \\n        <span class=\\"hljs-keyword\\">return</span> head;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/2.add_two_number/result.png\\" alt=\\"Result\\"></p>\\n<p>실행 시간은 28ms, 메모리 사용량은 71.4MB로 측정되었습니다. </p>\\n<p>다른 C++ 제출자보다 80% 좋은 속도를 보여주었다고 되어있는데, 더 빠른 속도의 코드를 확인해보니 거의 다 비슷비슷 한 것 같습니다. 정말 특별하게 최적화를 한 것이 아닌 이상 이정도가 평균일 것 같습니다.</p>\\n"}')},"948d":function(s,n,a){},"9c2e":function(s,n,a){},a050:function(s,n,a){"use strict";a("f4e4")},a682:function(s,n,a){},adc8:function(s,n,a){"use strict";a("1b53")},adeb:function(s,n,a){"use strict";a("1d16")},b4fe:function(s,n,a){"use strict";a("a682")},baca:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---1-two-sum\\">LeetCode - 1. Two Sum</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/two-sum/\\">LeetCode 1. Two Sun</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>LeetCode의 1번 문제인 Two Sum은 정수형 배열과 target 숫자를 입력받습니다. 그리고 정수형 배열 내 숫자들을 이용해 target 숫자를 만들 수 있는 숫자 2개를 찾아 index를 반환하는 문제입니다.</p>\\n<p>답은 <strong>정확히 하나만</strong> 존재하며 같은 원소는 사용하지 않습니다.</p>\\n<p>난이도는 <code>EASY</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>첫 번째로 떠올린 방법은 Brute force, 무차별 대입 방법입니다. 단순히 배열을 모두 순회하면서 두 숫자를 더했을 때 target 숫자와 동일한 index 두 개를 찾는 방법입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> x = <span class=\\"hljs-number\\">0</span> ; x &lt; nums.<span class=\\"hljs-built_in\\">size</span>() ; x++)\\n{\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> y = x + <span class=\\"hljs-number\\">1</span> ; y &lt; nums.<span class=\\"hljs-built_in\\">size</span>() ; y++)\\n    {\\n        <span class=\\"hljs-type\\">int</span> sumResult = nums[x] + nums[y];\\n\\n        <span class=\\"hljs-keyword\\">if</span> (target == sumResult)\\n        {\\n            <span class=\\"hljs-keyword\\">return</span> std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{x, y};\\n        }\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">int</span>&gt;();\\n}\\n</code></pre>\\n<p>정말 심플합니다. 단순히 이중 반복문을 이용하여 배열을 순회하면서 하나하나 덧셈하여 target과 동일한 결과의 index를 반환합니다.</p>\\n<p>다만 특별한점이라면 내부의 중첩된 반복문은 <code>x + 1</code>번째부터 시작하는데, 이는 문제에 적혀있던 같은 원소를 사용하지 않기 때문이며 그리고 숫자를 더할 때 <code>x + y</code>나 <code>y + x</code>의 결과는 동일하기 때문에 중복된 case를 수행하지 않게 하기 위함입니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/two_sum/sol1_result.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행 시간은 <code>463ms</code> 메모리는 <code>9.9MB</code>사용하였다. 테스트 케이스가 55개밖에 안되는데 사실상 0.5초가량 걸렸습니다.</p>\\n<p>O(n^2)의 코드이기 때문에 그닥 빠른 알고리즘은 아니란걸 알 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;tuple&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span>\\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt; <span class=\\"hljs-title\\">Answer</span><span class=\\"hljs-params\\">(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums, <span class=\\"hljs-type\\">int</span> target)</span>\\n    </span>{\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> x = <span class=\\"hljs-number\\">0</span> ; x &lt; nums.<span class=\\"hljs-built_in\\">size</span>() ; x++)\\n        {\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> y = x + <span class=\\"hljs-number\\">1</span> ; y &lt; nums.<span class=\\"hljs-built_in\\">size</span>() ; y++)\\n            {\\n                <span class=\\"hljs-type\\">int</span> sumResult = nums[x] + nums[y];\\n\\n                <span class=\\"hljs-keyword\\">if</span> (target == sumResult)\\n                {\\n                    <span class=\\"hljs-keyword\\">return</span> std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{x, y};\\n                }\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">int</span>&gt;();\\n    }\\n};\\n\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">main</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">void</span>)</span>\\n</span>{\\n    Solution sol;\\n\\n    std::vector&lt;std::tuple&lt;std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;, <span class=\\"hljs-type\\">int</span>&gt;&gt; problems {\\n        std::<span class=\\"hljs-built_in\\">make_tuple</span>(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">7</span>, <span class=\\"hljs-number\\">11</span>, <span class=\\"hljs-number\\">15</span>}, <span class=\\"hljs-number\\">9</span>),\\n        std::<span class=\\"hljs-built_in\\">make_tuple</span>(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{<span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">2</span> ,<span class=\\"hljs-number\\">4</span>}, <span class=\\"hljs-number\\">6</span>),\\n        std::<span class=\\"hljs-built_in\\">make_tuple</span>(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{<span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">3</span>}, <span class=\\"hljs-number\\">6</span>)\\n    };\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">auto</span> problem : problems)\\n    {\\n        <span class=\\"hljs-keyword\\">auto</span> answer = sol.<span class=\\"hljs-built_in\\">Answer</span>(std::<span class=\\"hljs-built_in\\">get</span>&lt;<span class=\\"hljs-number\\">0</span>&gt;(problem), std::<span class=\\"hljs-built_in\\">get</span>&lt;<span class=\\"hljs-number\\">1</span>&gt;(problem));\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> num : answer)\\n        {\\n            std::cout &lt;&lt; num &lt;&lt; <span class=\\"hljs-string\\">&quot; &quot;</span>;\\n        }\\n        std::cout &lt;&lt; std::endl;\\n    }\\n\\n}\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2---hash-table\\">Solution 2 - Hash table</h3>\\n<p><img src=\\"/assets/images/leet_code/two_sum/follow_up.png\\" alt=\\"Follow-up\\"></p>\\n<p>첫 번째 해결책은 O(n^2)의 코드이므로 이보다 더 빠른 해결책을 제시해보겠습니다.</p>\\n<p>첫 번째 방법의 문제점은 중첩된 반복문의 사용이며, 하나의 x를 정해 target에 맞는 y를 계속 찾는 방법입니다. 즉, 반복문이 돌며 x가 바뀌면 이전에 계산했던 모든 <code>x + y</code>의 계산 결과는 없어지며 새로운 x를 정해 다시 y를 찾아가는 여행을 떠나야 되게 됩니다.</p>\\n<p>여기서 생각을 바꾸어 이전에 나왔던 x를 별도의 메모리에 저장하여 <code>diff = target - x</code>를 수행하여 <code>diff</code>에 해당 하는 값이 이전에 등장한 적이 있다면 <code>diff + x = target</code>이 되므로 결국 diff와 x의 index를 반환하면 됩니다. 이렇게 되면 순회가 단 한번만 발생하니 O(n)이 됩니다.</p>\\n<p>그런데 여기서 또 발생하는 문제점은 x를 메모리에 저장한 후에 diff와 동일한 값을 찾을 때 저장한 공간을 순회해야 합니다. 만약 1차원 배열이라면 O(n)의 순회 시간이 발생할 것이며 즉, 결국 O(n^2)랑 차이가 없게되죠.</p>\\n<p>이를 해결하기 위해 일반 배열이 아닌 Hash Table을 사용합니다. Hash table은 Hash 함수를 key를 hash화 하여 저장할 index를 계산해 저장하는 방식이기 때문에 탐색과 삽입이 O(1)이 됩니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-comment\\">//                num, index</span>\\nstd::unordered_map&lt;<span class=\\"hljs-type\\">int</span>, <span class=\\"hljs-type\\">int</span>&gt; table;\\n\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> x = <span class=\\"hljs-number\\">0</span> ; x &lt; nums.<span class=\\"hljs-built_in\\">size</span>() ; x++)\\n{\\n    <span class=\\"hljs-type\\">int</span> diff = target - nums[x];\\n\\n    <span class=\\"hljs-keyword\\">auto</span> search = table.<span class=\\"hljs-built_in\\">find</span>(diff);\\n    <span class=\\"hljs-keyword\\">if</span> (search != table.<span class=\\"hljs-built_in\\">end</span>())\\n    {\\n        <span class=\\"hljs-keyword\\">return</span> std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{x, search-&gt;second};\\n    }\\n\\n    table.<span class=\\"hljs-built_in\\">insert</span>(std::<span class=\\"hljs-built_in\\">make_pair</span>(nums[x], x));\\n}\\n\\n<span class=\\"hljs-keyword\\">return</span> std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">int</span>&gt;();\\n</code></pre>\\n<p>C++의 <a href=\\"https://en.cppreference.com/w/cpp/container/unordered_map\\">unordered_map</a>은 key-value형태의 컨테이너이며 상수 시간내에 삽입, 삭제, 탐색, 비교가 이루어지는 자료구조 즉, Hash table입니다.</p>\\n<p>먼저 <code>diff = target - nums[x]</code>를 통해 target에 x를 빼면 남는 값 diff가 이미 등장한 적이 있는지 확인합니다.\\n만약 있다면 등장했었던 그 값의 index와 현재 x의 index를 반환하기만 하면 됩니다.</p>\\n<p>매우 간단하지만, 기존의 O(n^2) 코드에 비교하면 O(n)이므로 속도 향상이 매우 많이 이루어졌을 것이라고 생각됩니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/two_sum/sol2_result.png\\" alt=\\"Solution 2 result\\"></p>\\n<p>기존의 약 <code>500ms</code>의 속도에서 <code>7ms</code>의 속도로 70배 가까이 향상되었습니다. 다만 별도의 저장 공간을 사용했기에 메모리의 크기가 <code>9.9MB</code>에서 <code>10.7MB</code>로 증가했습니다.</p>\\n<details>\\n    <summary>코드 전문</summary>\\n\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;tuple&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;unordered_map&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span>\\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\">std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt; <span class=\\"hljs-title\\">Answer</span><span class=\\"hljs-params\\">(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums, <span class=\\"hljs-type\\">int</span> target)</span>\\n    </span>{\\n        <span class=\\"hljs-comment\\">//                num, index</span>\\n        std::unordered_map&lt;<span class=\\"hljs-type\\">int</span>, <span class=\\"hljs-type\\">int</span>&gt; table;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> x = <span class=\\"hljs-number\\">0</span> ; x &lt; nums.<span class=\\"hljs-built_in\\">size</span>() ; x++)\\n        {\\n            <span class=\\"hljs-type\\">int</span> diff = target - nums[x];\\n\\n            <span class=\\"hljs-keyword\\">auto</span> search = table.<span class=\\"hljs-built_in\\">find</span>(diff);\\n            <span class=\\"hljs-keyword\\">if</span> (search != table.<span class=\\"hljs-built_in\\">end</span>())\\n            {\\n                <span class=\\"hljs-keyword\\">return</span> std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{x, search-&gt;second};\\n            }\\n\\n            table.<span class=\\"hljs-built_in\\">insert</span>(std::<span class=\\"hljs-built_in\\">make_pair</span>(nums[x], x));\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> std::<span class=\\"hljs-built_in\\">vector</span>&lt;<span class=\\"hljs-type\\">int</span>&gt;();\\n    }\\n};\\n\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">main</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">void</span>)</span>\\n</span>{\\n    Solution sol;\\n\\n    std::vector&lt;std::tuple&lt;std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;, <span class=\\"hljs-type\\">int</span>&gt;&gt; problems {\\n        std::<span class=\\"hljs-built_in\\">make_tuple</span>(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">7</span>, <span class=\\"hljs-number\\">11</span>, <span class=\\"hljs-number\\">15</span>}, <span class=\\"hljs-number\\">9</span>),\\n        std::<span class=\\"hljs-built_in\\">make_tuple</span>(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{<span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">2</span> ,<span class=\\"hljs-number\\">4</span>}, <span class=\\"hljs-number\\">6</span>),\\n        std::<span class=\\"hljs-built_in\\">make_tuple</span>(std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{<span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">3</span>}, <span class=\\"hljs-number\\">6</span>)\\n    };\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">auto</span> problem : problems)\\n    {\\n        <span class=\\"hljs-keyword\\">auto</span> answer = sol.<span class=\\"hljs-built_in\\">Answer</span>(std::<span class=\\"hljs-built_in\\">get</span>&lt;<span class=\\"hljs-number\\">0</span>&gt;(problem), std::<span class=\\"hljs-built_in\\">get</span>&lt;<span class=\\"hljs-number\\">1</span>&gt;(problem));\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> num : answer)\\n        {\\n            std::cout &lt;&lt; num &lt;&lt; <span class=\\"hljs-string\\">&quot; &quot;</span>;\\n        }\\n        std::cout &lt;&lt; std::endl;\\n    }\\n\\n}\\n</code></pre>\\n</details>"}')},cba4:function(s){s.exports=JSON.parse('{"1":{"id":1,"name":"Leet Code","posts":[1,2,3,4,5,6,7,8,9,10,11]},"2":{"id":2,"name":"easy","posts":[1,9]},"3":{"id":3,"name":"c++","posts":[1,2,3,4,5,6,7,8,9,10,11]},"4":{"id":4,"name":"medium","posts":[2,3,5,6,7,8,11]},"5":{"id":5,"name":"hard","posts":[4,10]}}')},cd49:function(s,n,a){"use strict";a.r(n);a("e260"),a("e6cf"),a("cca6"),a("a79d");var e=a("7a23");function l(s,n,a,l,t,p){var c=Object(e["y"])("Header"),r=Object(e["y"])("router-view"),i=Object(e["y"])("Footer");return Object(e["q"])(),Object(e["d"])(e["a"],null,[Object(e["g"])(c),Object(e["g"])(r),Object(e["g"])(i)],64)}var t=a("3617"),p=Object(e["h"])({components:{Header:t["c"],Footer:t["b"]}});a("dcd8");p.render=l;var c=p,r=(a("d3b7"),a("3ca3"),a("ddb0"),a("6c02")),i=a("f7e2"),o=Object(e["F"])("data-v-1e6c83f9");Object(e["t"])("data-v-1e6c83f9");var h={class:"home"};Object(e["r"])();var d=o((function(s,n,a,l,t,p){var c=Object(e["y"])("post-list"),r=Object(e["y"])("ContentWithSideMenu");return Object(e["q"])(),Object(e["d"])(r,null,{default:o((function(){return[s.postFilter.type?(Object(e["q"])(),Object(e["d"])("div",{key:0,class:[s.postFilter.type,"post-filter"]},[Object(e["g"])("p",null,Object(e["A"])(s.selectedFilterName),1)],2)):Object(e["e"])("",!0),Object(e["g"])("main",h,[Object(e["g"])(c,{filter:s.postFilter},null,8,["filter"])])]})),_:1})})),j=(a("b0c0"),a("58a7")),u=Object(e["F"])("data-v-0e07973f");Object(e["t"])("data-v-0e07973f");var m={class:"post-item card"},g={key:0,class:"thumbnail"},b={class:"content"},y={class:"info"},f={class:"post-title"},w={key:0,class:"post-summery"};Object(e["r"])();var _=u((function(s,n,a,l,t,p){var c=Object(e["y"])("SeriesButton"),r=Object(e["y"])("FormattedDate"),i=Object(e["y"])("TagsView"),o=Object(e["y"])("router-link");return Object(e["q"])(),Object(e["d"])(o,{to:{name:"PostView",params:{id:s.post.uid}}},{default:u((function(){return[Object(e["g"])("div",m,[s.post.thumbnail?(Object(e["q"])(),Object(e["d"])("div",g,[Object(e["g"])("img",{src:s.post.thumbnail},null,8,["src"])])):Object(e["e"])("",!0),Object(e["g"])("div",b,[Object(e["g"])("div",y,[Object(e["g"])("h1",f,[Object(e["f"])(Object(e["A"])(s.post.title)+" ",1),s.post.series?(Object(e["q"])(),Object(e["d"])(c,{key:0,series:s.post.series},null,8,["series"])):Object(e["e"])("",!0)]),Object(e["g"])(r,{date:s.post.date},null,8,["date"]),s.post.tags.length>0?(Object(e["q"])(),Object(e["d"])(i,{key:0,class:"tags",tags:s.post.tags},null,8,["tags"])):Object(e["e"])("",!0)]),s.post.summery?(Object(e["q"])(),Object(e["d"])("p",w,Object(e["A"])(s.post.summery),1)):Object(e["e"])("",!0)])])]})),_:1},8,["to"])})),k=a("7e73"),v=Object(e["h"])({name:"PostItem",components:{TagsView:k["c"],SeriesButton:k["a"],FormattedDate:t["a"]},props:{post:{type:Object,required:!0}}});a("ceb9");v.render=_,v.__scopeId="data-v-0e07973f";var O=v,x=Object(e["F"])("data-v-7e2fd040");Object(e["t"])("data-v-7e2fd040");var L={class:"post-list"};Object(e["r"])();var S=x((function(s,n,a,l,t,p){var c=Object(e["y"])("post-item");return Object(e["q"])(),Object(e["d"])("div",L,[(Object(e["q"])(!0),Object(e["d"])(e["a"],null,Object(e["w"])(s.posts,(function(s){return Object(e["q"])(),Object(e["d"])(c,{class:"post-item",key:s.uid,post:s},null,8,["post"])})),128))])})),M=(a("4de4"),Object(e["h"])({name:"PostList",props:{filter:{type:Object}},components:{PostItem:O},setup:function(s){var n=Object(e["i"])(),a=null===n||void 0===n?void 0:n.appContext.config.globalProperties.$postLoader,l=Object(e["b"])((function(){var n;return null!==(n=s.filter)&&void 0!==n&&n.type?a.GetRecentPosts(-1,0,s.filter):a.GetRecentPosts(-1)}));return{posts:l}}}));a("f9f1");M.render=S,M.__scopeId="data-v-7e2fd040";var N=M,z=Object(e["h"])({name:"Home",components:{PostList:N,ContentWithSideMenu:j["a"]},setup:function(){var s=Object(r["c"])(),n=Object(e["u"])({type:"",id:-1}),a=function(s){if(s){var a=s.series,e=s.tag,l=a?"series":e?"tag":"",t=a?parseInt(a):e?parseInt(e):-1;n.type=l,n.id=t}};a(s.query),Object(e["D"])((function(){return s.query}),a);var l=Object(e["i"])(),t=null===l||void 0===l?void 0:l.appContext.config.globalProperties.$postLoader,p=Object(e["b"])((function(){return"series"===n.type?t.seriesMetadata[n.id].name:"tag"===n.type?t.tagsMetadata[n.id].name:""}));return{postFilter:n,selectedFilterName:p}}});a("3715");z.render=d,z.__scopeId="data-v-1e6c83f9";var A=z,I=a("3e94"),q=a.n(I),C=Object(e["F"])("data-v-19c80930");Object(e["t"])("data-v-19c80930");var F={class:"about"},P=Object(e["g"])("div",{class:"card content"},[Object(e["g"])("p",null,"곧 주인장에 대한 설명과 이력 등등이 추가될 예정입니다."),Object(e["g"])("br"),Object(e["g"])("p",null,"추가될 때 까지 귀여운 고양이를 드립니다."),Object(e["g"])("img",{src:q.a})],-1);Object(e["r"])();var R=C((function(s,n){return Object(e["q"])(),Object(e["d"])("div",F,[P])}));a("4eaf");const T={};T.render=R,T.__scopeId="data-v-19c80930";var B=T,E=Object(e["F"])("data-v-62d5e77b");Object(e["t"])("data-v-62d5e77b");var D={class:"page-not-found"},H=Object(e["g"])("p",null,"404",-1),W=Object(e["g"])("p",null,"Page Not Found",-1);Object(e["r"])();var J=E((function(s,n){return Object(e["q"])(),Object(e["d"])("div",D,[H,W])}));a("a050");const X={};X.render=J,X.__scopeId="data-v-62d5e77b";var U=X,Y=Object(e["F"])("data-v-6f490642");Object(e["t"])("data-v-6f490642");var V={class:"error"},G=Object(e["g"])("p",null,"Error!",-1);Object(e["r"])();var K=Y((function(s,n){return Object(e["q"])(),Object(e["d"])("div",V,[G])}));a("adeb");const $={};$.render=K,$.__scopeId="data-v-6f490642";var Z=$,Q=[{path:"/",name:"Home",component:A},{path:"/about",name:"About",component:B},{path:"/post/:id(\\d+)",name:"PostView",component:function(){return a.e("post_view").then(a.bind(null,"7afb"))}},{path:"/:pathMatch(.*)*",name:"NotFound",component:U},{path:"/error",name:"Error",component:Z}],ss=Object(r["a"])({history:Object(r["b"])("/"),routes:Q,scrollBehavior:function(s,n,a){return a||(s.hash?{el:s.hash,behavior:"smooth"}:{top:0})}});Object(i["b"])(ss);var ns=ss,as=a("d4ec"),es=a("bee2"),ls=(a("4e82"),a("caad"),a("2532"),a("d81d"),a("fb6a"),a("7db0"),a("c740"),a("5a0c")),ts=a.n(ls),ps=function(){function s(n,a){var e,l=this;Object(as["a"])(this,s),this._nextPostId=null,this._prevPostId=null;var t=a.postMetadatas.find((function(s){return s.uid===n}));if(!t)throw new Error("Faild to find post metadata by id");var p=null!==(e=a.seriesMetadata[t.series])&&void 0!==e?e:null,c=t.tags.map((function(s){return a.tagsMetadata[s]}));if(this.postMeta=t,this.seriesMeta=p,this.tagsMeta=c,this.seriesMeta){var r,i,o=this.seriesMeta.posts.findIndex((function(s){return s===l.uid}));this._nextPostId=null!==(r=this.seriesMeta.posts[o+1])&&void 0!==r?r:null,this._prevPostId=null!==(i=this.seriesMeta.posts[o-1])&&void 0!==i?i:null}}return Object(es["a"])(s,[{key:"uid",get:function(){return this.postMeta.uid}},{key:"title",get:function(){return this.postMeta.title}},{key:"date",get:function(){return ts()(this.postMeta.date)}},{key:"thumbnail",get:function(){return this.postMeta.thumbnail}},{key:"summery",get:function(){return this.postMeta.summery}},{key:"series",get:function(){return this.seriesMeta}},{key:"tags",get:function(){return this.tagsMeta}},{key:"postContent",get:function(){var s=a("e003")("./".concat(this.postMeta.htmlFileName));return s.content}},{key:"nextSeriesId",get:function(){return this._nextPostId}},{key:"prevSeriesId",get:function(){return this._prevPostId}}]),s}(),cs=function(){function s(){Object(as["a"])(this,s),this._postMetadatas=a("14b9"),this._seriesMetadata=a("fb39"),this._tagsMetadata=a("cba4")}return Object(es["a"])(s,[{key:"postMetadatas",get:function(){return this._postMetadatas}},{key:"seriesMetadata",get:function(){return this._seriesMetadata}},{key:"tagsMetadata",get:function(){return this._tagsMetadata}},{key:"GetRecentPosts",value:function(){var s=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,l=this.postMetadatas.sort((function(s,n){return s.date==n.date?0:s.date>n.date?-1:1}));return e&&(l=l.filter((function(s){return"series"==e.type?e.id===s.series:"tag"==e.type?s.tags.includes(e.id):void 0}))),-1==n?l.map((function(n){return new ps(n.uid,s)})):l.slice(a,n).map((function(n){return new ps(n.uid,s)}))}},{key:"GetPostById",value:function(s){try{var n=new ps(s,this);return n}catch(a){return console.log(a),null}}}]),s}();a("f20b");ts.a.locale("ko");var rs=Object(e["c"])(c);rs.config.globalProperties.$postLoader=new cs,rs.use(ns).use(i["a"],{property:{id:"G-BLG37NTK4J"}}).mount("#app")},ceb9:function(s,n,a){"use strict";a("edd8")},dcd8:function(s,n,a){"use strict";a("5e6b")},e003:function(s,n,a){var e={"./2021-10-24-leet_code_1":"baca","./2021-10-24-leet_code_1.json":"baca","./2021-10-26-leet_code_2":"83f9","./2021-10-26-leet_code_2.json":"83f9","./2021-10-27-leet_code_3":"6bc8","./2021-10-27-leet_code_3.json":"6bc8","./2021-10-29-leet_code_4":"7851","./2021-10-29-leet_code_4.json":"7851","./2021-11-06-leet_code_5":"0919","./2021-11-06-leet_code_5.json":"0919","./2021-11-07-leet_code_6":"09f0","./2021-11-07-leet_code_6.json":"09f0","./2021-11-08-leet_code_7":"5f26","./2021-11-08-leet_code_7.json":"5f26","./2021-11-08-leet_code_8":"2fa2","./2021-11-08-leet_code_8.json":"2fa2","./2021-11-08-leet_code_9":"ef05","./2021-11-08-leet_code_9.json":"ef05","./2021-11-10-leet_code_10":"3c34","./2021-11-10-leet_code_10.json":"3c34","./2021-11-13-leet_code_11":"25b4","./2021-11-13-leet_code_11.json":"25b4"};function l(s){var n=t(s);return a(n)}function t(s){if(!a.o(e,s)){var n=new Error("Cannot find module '"+s+"'");throw n.code="MODULE_NOT_FOUND",n}return e[s]}l.keys=function(){return Object.keys(e)},l.resolve=t,s.exports=l,l.id="e003"},e1c4:function(s,n,a){s.exports=a.p+"img/귀여운_고양이_1.dfb645d4.jpg"},ea47:function(s,n,a){s.exports=a.p+"img/profile_image.d79e9dd8.png"},ecef:function(s,n,a){"use strict";a("eeac")},edd8:function(s,n,a){},eeac:function(s,n,a){},ef05:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---9-palindrome-number\\">LeetCode - 9. Palindrome Number</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/palindrome-number/\\">LeetCode 9. Palindrome Number</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>정수형 입력값이 회문인지 검사합니다. 만약 121이 입력된다면 121을 뒤집은 값도 121이니 회문입니다.</p>\\n<p>만약 -121이 들어온다면 뒤집었을 때 121-가 되므로 회문이 아닙니다. 123 또한 뒤집었을 때 321이 되므로 회문이 아닙니다.</p>\\n<p>난이도는 <code>EASY</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution\\">Solution</h3>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isPalindrome</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> x)</span> \\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (x &lt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (x &lt; <span class=\\"hljs-number\\">10</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> ((x % <span class=\\"hljs-number\\">10</span>) == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n\\n    <span class=\\"hljs-type\\">long</span> reverse = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">long</span> tmpX = x;\\n\\n    <span class=\\"hljs-keyword\\">while</span> (tmpX)\\n    {\\n        reverse = (reverse * <span class=\\"hljs-number\\">10</span>) + (tmpX % <span class=\\"hljs-number\\">10</span>);\\n        tmpX /= <span class=\\"hljs-number\\">10</span>;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> reverse == x;\\n}\\n</code></pre>\\n<p>먼저 음수인 경우 절대 회문이 될 수 없기 때문에 <code>false</code>를 반환합니다.</p>\\n<p>숫자가 한 자리인 경우는 무조건 회문이기 때문에 <code>true</code>를 반환합니다.</p>\\n<p>10의 배수는 10, 20, ... 120, 130 등 회문이 절대 될 수 없기 때문에 <code>false</code>를 반환합니다.</p>\\n<p>입력값 x를 뒤집은 값 reverse를 구합니다. reverse의 타입이 <code>long</code>인 이유는 x값이 <code>int</code>자료형의 최대값이 들어오는 경우 뒤집을 때 연산 중 에러가 발생하기 때문에 <code>int</code>보다 큰 자료형인 <code>long</code> 자료형을 사용합니다.(별도의 자료형 제한을 두지 않았기 때문에 사용하였습니다.)</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/9/result.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>0ms의 실행 결과가 표현되었으며, 다른 C++ 제출자보다 100%의 성능을 보였음을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">bool</span> <span class=\\"hljs-title\\">isPalindrome</span><span class=\\"hljs-params\\">(<span class=\\"hljs-type\\">int</span> x)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (x &lt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (x &lt; <span class=\\"hljs-number\\">10</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> ((x % <span class=\\"hljs-number\\">10</span>) == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n\\n        <span class=\\"hljs-type\\">long</span> reverse = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">long</span> tmpX = x;\\n\\n        <span class=\\"hljs-keyword\\">while</span> (tmpX)\\n        {\\n            reverse = (reverse * <span class=\\"hljs-number\\">10</span>) + (tmpX % <span class=\\"hljs-number\\">10</span>);\\n            tmpX /= <span class=\\"hljs-number\\">10</span>;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> reverse == x;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')},f4e4:function(s,n,a){},f9f1:function(s,n,a){"use strict";a("948d")},fb39:function(s){s.exports=JSON.parse('{"1":{"id":1,"name":"LeetCode","posts":[1,2,3,4,5,6,7,8,9,10,11]}}')}});
//# sourceMappingURL=app.0d781abd.js.map