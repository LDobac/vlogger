(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["post-2021-10-27-leet_code_3-4"],{"6bc8":function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---3-longest-substring-without-repeating-characters\\">LeetCode - 3. Longest Substring Without Repeating Characters</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\\">LeetCode 3. Longest Substring Without Repeating Characters</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p>특정 문자열 <code>s</code>가 주어질 때 똑같은 문자를 반복하지 않는, 가장 긴 부분 문자열을 구하는 문제입니다.</p>\\n<p><img src=\\"/assets/images/leet_code/3/exam.png\\" alt=\\"Problem Example\\"></p>\\n<p>만약 입력 문자열이 <code>s = &quot;abcabcbb&quot;</code>라면 반복하는 bb를 제외하고, 반복하지 않는 문자열인 &quot;abc&quot;의 길이인 3이 구해집니다.</p>\\n<p>즉, 부분 문자열에서 동일한 문자가 없는, 가장 긴 길이의 부분 문자열을 구합니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>첫 번째 시도는 무차별 대입을 통한 검사를 진행합니다.</p>\\n<p>만약 s 문자열의 길이가 n이라면 i가 0-&gt;n 일때 i ~ n사이의 부분 문자열을 계속 찾습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n</span>{\\n    <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n    {\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> sliceStart = i;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n        {\\n            std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(sliceStart, length);\\n            <span class=\\"hljs-type\\">int</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(j));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (pos == std::string::npos)\\n            {\\n                <span class=\\"hljs-comment\\">// Not found</span>\\n                length++;\\n\\n                longestLength = (longestLength &lt; length) ? length : longestLength;\\n            }\\n            <span class=\\"hljs-keyword\\">else</span>\\n            {\\n                <span class=\\"hljs-keyword\\">break</span>;\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() - i &lt; longestLength) <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> longestLength;\\n}\\n</code></pre>\\n<p>중첩된 반복문을 이용해 모든 경우의 수를 탐색합니다.</p>\\n<p>문자열을 찾는 주요 부분은 내부 반복문이니 내부 반복문만 따로 빼서 확인해보겠습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n{\\n    std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(sliceStart, length);\\n    <span class=\\"hljs-type\\">int</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(j));\\n\\n    <span class=\\"hljs-keyword\\">if</span> (pos == std::string::npos)\\n    {\\n        <span class=\\"hljs-comment\\">// Not found</span>\\n        length++;\\n\\n        longestLength = (longestLength &lt; length) ? length : longestLength;\\n    }\\n    <span class=\\"hljs-keyword\\">else</span>\\n    {\\n        <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n}\\n</code></pre>\\n<p>j는 i -&gt; n까지 증가합니다. 문자열 s를 i부터 length 길이만큼 잘라 부분 문자열을 생성합니다. 문자열 s의 j번째 문자를 가져와 현재 부분 문자열에 동일한 문자가 있는지 검사합니다.</p>\\n<p>만약 현재 추출한 부분 문자열에 동일한 문자(중복되는 문자)가 없다면 부분 문자열의 길이를 1 증가합니다.</p>\\n<p>중복된 문자열이 존재하다면 반복문을 탈출합니다.</p>\\n<p>위 반복문을 s문자열의 길이 n번만큼 반복합니다. 즉, O(n^2)의 알고리즘이 됩니다. 추가로 이 코드에서는 문자열을 탐색할 때 라이브러리의 함수를 사용하였지만, 선형 탐색을 통하여 문자열을 탐색한다면 O(n^3)의 알고리즘이 될 수도 있습니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/3/result_1.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>실행 시간은 628ms, 메모리 사용량은 273.1MB가 나오게 되었습니다. 동일한 C++ 제출자에 비해서 8.92% 정도밖에 빠르지 않은 매우 느린 코드임을 알 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span> ; i &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; i++)\\n        {\\n            <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n            <span class=\\"hljs-type\\">int</span> sliceStart = i;\\n\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = i ; j &lt; s.<span class=\\"hljs-built_in\\">size</span>() ; j++)\\n            {\\n                std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(sliceStart, length);\\n                <span class=\\"hljs-type\\">int</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(j));\\n\\n                <span class=\\"hljs-keyword\\">if</span> (pos == std::string::npos)\\n                {\\n                    <span class=\\"hljs-comment\\">// Not found</span>\\n                    length++;\\n\\n                    longestLength = (longestLength &lt; length) ? length : longestLength;\\n                }\\n                <span class=\\"hljs-keyword\\">else</span>\\n                {\\n                    <span class=\\"hljs-keyword\\">break</span>;\\n                }\\n            }\\n\\n            <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() - i &lt; longestLength) <span class=\\"hljs-keyword\\">break</span>;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> longestLength;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2---sliding-window\\">Solution 2 - Sliding window</h3>\\n<p>첫 번째 방법의 문제점은 중첩된 반복문을 순회하면서 이미 검사한 문자열을 또 다시 검사하기 때문에 좋은 속도가 나지 않았습니다.</p>\\n<p>아이디어를 살짝 바꾸어서 생각해보겠습니다. 문자열 <code>s = &quot;abcabcbb&quot;</code>가 주어질 때 여기서 중복되지 않는 문자들의 집합인 부분 문자열의 길이가 가장 긴 것을 구하는 것입니다.</p>\\n<p>때문에 부분 문자열이 &quot;abc&quot;이든 &quot;bca&quot;이든 조건을 만족하면서 가장 긴 부분 문자열이 되게 됩니다.</p>\\n<p>문자열을 검사하면서 &quot;abc&quot;에서 &quot;abca&quot;가 되었다면 이때 문자 &quot;a&quot;가 겹치게 되므로 이 문자열은 정답이 될 수 없습니다. 하지만 &quot;abca&quot;를 다시 조건에 맞는 문자열로 바꾸는 방법은 맨 뒤의 &quot;a&quot;를 제거할 수도 있지만, 반대로 맨 처음의 &quot;a&quot;를 제거할 수도 있습니다.</p>\\n<p>즉, &quot;abca&quot; -&gt; &quot;bca&quot;로 변환한다면 조건에 만족하는 문자열이 되게 됩니다. 이때 왼쪽의 index를 <code>left</code>, 오른쪽의 index를 <code>right</code>라 한다면 <code>left</code>를 1 증가시키기만 하면 반복문을 처음부터 순회할 필요 없이 정답에 맞는 조건이 되게 됩니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n    {\\n        std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(left, length);\\n        <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n        <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n        {\\n            left += (pos + <span class=\\"hljs-number\\">1</span>);\\n        }\\n        \\n        right++;\\n        length = right - left;\\n\\n        longestLength = (longestLength &lt; length) ? length : longestLength;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> longestLength;\\n}\\n</code></pre>\\n<p>sliding window를 구성하는 left, right 변수를 추가하여 매 순회시 마다 right 즉, window를 늘려갑니다.</p>\\n<p>만약 중복되는 문자열이 부분 문자열 내에 있다면 해당 index(pos)만큼 더하여 window를 줄입니다(sliding).</p>\\n<p>오히려 코드가 훨씬 간단해지고 루프문도 하나로 줄었으니 O(n)정도의 성능을 기대할 수 있을 것 같습니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/3/result_2.png\\" alt=\\"Solution 2 result\\"></p>\\n<p>코드의 실행 속도는 16ms로 향상되었으며 사용 메모리도 11.6MB로 크게 향상되었습니다. 다른 C++ 제출자에 비해서 66.67%의 빠른 성능을 보여줌을 확인할 수 있었습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n        {\\n            std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(left, length);\\n            <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n            {\\n                left += (pos + <span class=\\"hljs-number\\">1</span>);\\n            }\\n            \\n            right++;\\n            length = right - left;\\n\\n            longestLength = (longestLength &lt; length) ? length : longestLength;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> longestLength;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-3---sliding-window-optimized-stdstring\\">Solution 3 - sliding window optimized std::string</h3>\\n<p>2 번째 방법의 경우 <strong>std::string</strong>의 부분 문자열을 구하는 함수인 <strong>substr</strong> 함수를 이용했습니다.</p>\\n<pre><code class=\\"language-c++\\">std::string substr = s.<span class=\\"hljs-built_in\\">substr</span>(left, length);\\n<span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n</code></pre>\\n<p>위 함수가 현재 상황에서 발생하는 문제점은 <strong>substr</strong>함수는 문자열을 자른 후 새로운 std::string 객체를 생성하여 반환하게 됩니다. 즉 문자열을 자른 후 메모리를 할당하는 과정이 생기기에 overhead가 발생합니다.</p>\\n<p>이러한 문제를 해결하기 위해서 C++ 17부터는 <a href=\\"https://en.cppreference.com/w/cpp/string/basic_string_view\\">std::string_view</a>라는 객체가 도입되었습니다.</p>\\n<p><strong>std::string_view</strong> 객체는 기본적으로 char*의 포인터와 문자열의 길이(size)만 가지는 문자열 객체이며 사실상 char* 타입에 간단한 부분 문자열, 문자열 찾기와 같은 함수만 추가한 객체입니다.</p>\\n<p>객체의 생성, 탐색과 같은 부분이 최소 O(1)에서 O(n)내의 연산으로 이루어져있기 때문에 문자열을 이용해 복잡한 연산이나 변형을 하지 않고 탐색만 한다면 매우 적절한 클래스입니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n</span>{\\n    <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n    <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n    {\\n        <span class=\\"hljs-comment\\">// std::string -&gt; std::string_view</span>\\n        <span class=\\"hljs-function\\">std::string_view <span class=\\"hljs-title\\">substr</span><span class=\\"hljs-params\\">(&amp;s[left], length)</span></span>;\\n        <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n        <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n        {\\n            left += (pos + <span class=\\"hljs-number\\">1</span>);\\n        }\\n        \\n        right++;\\n        length = right - left;\\n\\n        longestLength = (longestLength &lt; length) ? length : longestLength;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> longestLength;\\n}\\n</code></pre>\\n<p>유일하게 변경된 점은 <strong>std::string</strong> -&gt; <strong>std::string_view</strong>로만 변경되었습니다. 다행히 <strong>std::string_view</strong>클래스도 substr을 지원하기 때문에 간단히 사용 가능합니다.</p>\\n<h4 id=\\"제출-결과-2\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/3/result_3.png\\" alt=\\"Solution 3 result\\"></p>\\n<p>실행 시간은 4ms, 메모리는 6.7MB로 다른 방법에 비해서 속도와 메모리가 월등히 향상되었습니다.</p>\\n<p>다른 C++ 제출자에 비해서 96%나 빠른 성능을 보여줌을 확인할 수 있습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n    \\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;string_view&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">lengthOfLongestSubstring</span><span class=\\"hljs-params\\">(std::string s)</span> \\n    </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (s.<span class=\\"hljs-built_in\\">size</span>() == <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> longestLength = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-type\\">int</span> left = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> right = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-type\\">int</span> length = <span class=\\"hljs-number\\">0</span>;\\n\\n        <span class=\\"hljs-keyword\\">while</span>(right &lt; s.<span class=\\"hljs-built_in\\">size</span>())\\n        {\\n            <span class=\\"hljs-function\\">std::string_view <span class=\\"hljs-title\\">substr</span><span class=\\"hljs-params\\">(&amp;s[left], length)</span></span>;\\n            <span class=\\"hljs-keyword\\">auto</span> pos = substr.<span class=\\"hljs-built_in\\">find_first_of</span>(s.<span class=\\"hljs-built_in\\">at</span>(right));\\n\\n            <span class=\\"hljs-keyword\\">if</span> (pos != std::string::npos)\\n            {\\n                left += (pos + <span class=\\"hljs-number\\">1</span>);\\n            }\\n            \\n            right++;\\n            length = right - left;\\n\\n            longestLength = (longestLength &lt; length) ? length : longestLength;\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> longestLength;\\n    }\\n};\\n</code></pre>\\n</details>"}')}}]);
//# sourceMappingURL=post-2021-10-27-leet_code_3-4.810e1c0c.js.map