"use strict";(self["webpackChunkvlogger"]=self["webpackChunkvlogger"]||[]).push([[294],{100:function(s){s.exports=JSON.parse('{"content":"<h2 id=\\"leetcode---15-3sum\\">LeetCode - 15. 3Sum</h2>\\n<p>문제 - <a href=\\"https://leetcode.com/problems/3sum/\\">LeetCode 15. 3Sum</a></p>\\n<h2 id=\\"문제-설명\\">문제 설명</h2>\\n<p><a href=\\"\\">LeetCode - 2. Add Two Numbers</a>과 유사한 문제입니다.</p>\\n<p>숫자 배열이 주어지면 세 숫자의 합이 0이 되는 모든 가짓수를 찾아내는 문제입니다.</p>\\n<pre><code>Input : [-1, 0, 1, 2, -1, 4]\\nOutput : [[-1, -1, 2], [-1, 0, 1]]\\n</code></pre>\\n<p>또한 중복은 허용되지 않습니다.</p>\\n<p>난이도는 <code>MEDIUM</code> 난이도 입니다.</p>\\n<p>난이도는 중간 난이도이지만 실제 체감 난이도는 <code>HARD</code>나 다름 없었던것 같네요.</p>\\n<h2 id=\\"풀이\\">풀이</h2>\\n<p><a href=\\"https://github.com/LDobac/leetcode/tree/master/15.%203Sum\\">My Solutions(Github)</a></p>\\n<h3 id=\\"solution-1---brute-force\\">Solution 1 - Brute force</h3>\\n<p>늘 그렇듯 첫 번째 시도는 Brute force를 통해 단순히 코드를 짜는 것부터 시작해보겠습니다.</p>\\n<p>총 세 개의 숫자를 찾아야하니 3중 중첩 loop을 이용해 풀어낼 수 있습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n{\\n    num1 = nums[i];\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span>; j &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); j++)\\n    {\\n        <span class=\\"hljs-keyword\\">if</span> (j == i) <span class=\\"hljs-keyword\\">continue</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num1 &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[j] &gt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num1 &lt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[j] &lt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>; \\n\\n        num2 = num1 + nums[j];\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> k = <span class=\\"hljs-number\\">0</span>; k &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); k++)\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (j == k || i == k) <span class=\\"hljs-keyword\\">continue</span>;\\n            <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num2 &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[k] &gt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>;\\n            <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num2 &lt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[k] &lt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>; \\n\\n            num3 = num2 + nums[k];\\n\\n            <span class=\\"hljs-keyword\\">if</span> (num3 == <span class=\\"hljs-number\\">0</span>)\\n            {\\n                ...\\n            }\\n        }\\n    }\\n}\\n</code></pre>\\n<p>루프를 돌면서 첫 번째로 중복 검사를 위해 i, j, k가 동일한 인덱스인지 확인합니다. 만약 동일한 인덱스라면 중복된 것이므로 continue를 수행합니다.</p>\\n<p>두 번째로 약간의 최적화를 노리기 위해 현재의 숫자가 0에 가까워지는 숫자를 선택할 수 있도록 합니다.</p>\\n<p>그리고 선택된 세 숫자의 합이 0이라면 해당 숫자를 결과 배열에 삽입할 수 있습니다.</p>\\n<p>하지만, 중복을 허용하지 않기 때문에 <code>[-1, -1, 2]</code>와 <code>[-1, 2, -1]</code>에서 <code>-1</code>의 인덱스가 모두 다르더라도 <code>-1</code>이 중복이기 때문에 현재 결과에서 중복을 확인할 필요가 있습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">auto</span> v = vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{nums[i], nums[j], nums[k]};\\n<span class=\\"hljs-built_in\\">sort</span>(v.<span class=\\"hljs-built_in\\">begin</span>(), v.<span class=\\"hljs-built_in\\">end</span>()); \\n\\n<span class=\\"hljs-type\\">bool</span> push = <span class=\\"hljs-literal\\">true</span>;\\n\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">size_t</span> w = <span class=\\"hljs-number\\">0</span>; w &lt; result.<span class=\\"hljs-built_in\\">size</span>(); w++)\\n{\\n    <span class=\\"hljs-keyword\\">if</span> (result[w] == v)\\n    {\\n        push = <span class=\\"hljs-literal\\">false</span>;\\n        <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n}\\n\\n<span class=\\"hljs-keyword\\">if</span> (push)\\n{\\n    result.<span class=\\"hljs-built_in\\">push_back</span>(v);\\n}\\n</code></pre>\\n<p>결과를 정렬하여 이미 결과에 있는지 확인합니다. 만약 중복이라면 결과 배열에 삽입하지 않습니다.</p>\\n<h4 id=\\"제출-결과\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/15/result_2.png\\" alt=\\"Solution 1 result\\"></p>\\n<p>예상대로 시간 초과가 발생했습니다. 세 숫자를 찾는 3중 반복문에서 O(n^3)의 시간 복잡도가 발생하고, 마지막에 결과에서 중복된 부분을 제거할때도 반복문이 사용되기 때문에 사실상 O(n^4)의 시간 복잡도가 계산됩니다.</p>\\n<p>정렬도 하기 때문에 사실상 O(n^5)의 시간 복잡도라고 봐도 될 듯 합니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    vector&lt;vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&gt; <span class=\\"hljs-built_in\\">threeSum</span>(vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums) \\n    {\\n        vector&lt;vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&gt; result;\\n\\n        <span class=\\"hljs-type\\">int</span> num1, num2, num3;\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n        {\\n            num1 = nums[i];\\n\\n            <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> j = <span class=\\"hljs-number\\">0</span>; j &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); j++)\\n            {\\n                <span class=\\"hljs-keyword\\">if</span> (j == i) <span class=\\"hljs-keyword\\">continue</span>;\\n                <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num1 &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[j] &gt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>;\\n                <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num1 &lt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[j] &lt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>; \\n\\n                num2 = num1 + nums[j];\\n\\n                <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> k = <span class=\\"hljs-number\\">0</span>; k &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); k++)\\n                {\\n                    <span class=\\"hljs-keyword\\">if</span> (j == k || i == k) <span class=\\"hljs-keyword\\">continue</span>;\\n                    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num2 &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[k] &gt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>;\\n                    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (num2 &lt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[k] &lt; <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">continue</span>; \\n\\n                    num3 = num2 + nums[k];\\n\\n                    <span class=\\"hljs-keyword\\">if</span> (num3 == <span class=\\"hljs-number\\">0</span>)\\n                    {\\n                        <span class=\\"hljs-keyword\\">auto</span> v = vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{nums[i], nums[j], nums[k]};\\n                        <span class=\\"hljs-built_in\\">sort</span>(v.<span class=\\"hljs-built_in\\">begin</span>(), v.<span class=\\"hljs-built_in\\">end</span>()); \\n\\n                        <span class=\\"hljs-type\\">bool</span> push = <span class=\\"hljs-literal\\">true</span>;\\n\\n                        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">size_t</span> w = <span class=\\"hljs-number\\">0</span>; w &lt; result.<span class=\\"hljs-built_in\\">size</span>(); w++)\\n                        {\\n                            <span class=\\"hljs-keyword\\">if</span> (result[w] == v)\\n                            {\\n                                push = <span class=\\"hljs-literal\\">false</span>;\\n                                <span class=\\"hljs-keyword\\">break</span>;\\n                            }\\n                        }\\n\\n                        <span class=\\"hljs-keyword\\">if</span> (push)\\n                        {\\n                            result.<span class=\\"hljs-built_in\\">push_back</span>(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n};\\n</code></pre>\\n</details>\\n\\n<h3 id=\\"solution-2\\">Solution 2</h3>\\n<p>생각을 바꿔서 입력되는 숫자를 정렬합니다.</p>\\n<p>만약 <code>[-1, 0, 1, 2, -1, 4]</code>라는 숫자가 주어진다면 <code>[-1, -1, 0, 1, 2, 4]</code>로 정렬할 수 있습니다.</p>\\n<p>여기서 첫 번째 숫자인 <code>-1</code>과 마지막 숫자인 <code>4</code>를 더하면 <code>3</code>을 계산할 수 있습니다.</p>\\n<p><code>3</code>은 0보다 크기 마지막 숫자인 <code>4</code> 대신 한 칸 앞에 위치한 <code>2</code>를 선택합니다. 그럼 <code>-1 + 2 = 1</code>로 첫 번째 계산보다 0에 가까워졌음을 확인할 수 있습니다.</p>\\n<p>이를 통해 왼쪽 인덱스(left)와 오른쪽 인덱스(right)를 두어 적절히 인덱스를 변경하면서 0에 점점 가깝게 계산할 수 있습니다.</p>\\n<p>이번 문제는 숫자를 3개를 선택하는 문제이니 간단히 하나의 숫자를 고정하고 left와 right를 움직여서 0을 도출할 수 있습니다. 그리고 고정된 숫자를 숫자 배열의 처음부터 끝까지 순회하면 세 숫자를 더했을 때 0이 도출되는 모든 가짓수를 구할 수 있습니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-built_in\\">sort</span>(nums.<span class=\\"hljs-built_in\\">begin</span>(), nums.<span class=\\"hljs-built_in\\">end</span>());\\n</code></pre>\\n<p>먼저 입력으로 들어온 숫자 배열을 정렬합니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n{\\n    <span class=\\"hljs-keyword\\">if</span> (i &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">continue</span>;\\n\\n    ...\\n}\\n</code></pre>\\n<p>그리고 숫자 배열을 순회합니다. nums[i]는 해당 순회에서 고정될 숫자입니다</p>\\n<p><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></p>\\n<p>위 구문은 중복된 결과를 제외하기 위한 조건문입니다. 현재 고정할 숫자(nums[i])가 nums[i - 1]와 같다면 현재 반복문은 건너뜁니다.</p>\\n<p><img src=\\"/assets/images/leet_code/15/eg_1.png\\" alt=\\"explain 1\\"></p>\\n<p>nums[i] == nums[i - 1]라면 nums[i - 1]번째 순회시 찾은 모든 결과를 위 이미지와 같이 집합으로 표현한다면 nums[i]는 nums[i - 1]에서 찾은 결과의 부분 집합이 되기때문에 중복된 결과가 발생할 수 있습니다.</p>\\n<p>때문에 nums[i] == nums[i - 1]인 경우는 건너뜁니다.</p>\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-type\\">int</span> left = i + <span class=\\"hljs-number\\">1</span>;\\n<span class=\\"hljs-type\\">int</span> right = nums.<span class=\\"hljs-built_in\\">size</span>() - <span class=\\"hljs-number\\">1</span>;\\n\\n<span class=\\"hljs-keyword\\">while</span> (left &lt; right)\\n{\\n    <span class=\\"hljs-type\\">int</span> sum = nums[i] + nums[left] + nums[right];\\n\\n    <span class=\\"hljs-keyword\\">if</span> (sum &gt; <span class=\\"hljs-number\\">0</span>) right--;\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (sum &lt; <span class=\\"hljs-number\\">0</span>) left++;\\n    <span class=\\"hljs-keyword\\">else</span>\\n    {\\n        result.<span class=\\"hljs-built_in\\">push_back</span>(vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{nums[i], nums[left], nums[right]});\\n\\n        left++;\\n        <span class=\\"hljs-keyword\\">while</span> (nums[left] == nums[left - <span class=\\"hljs-number\\">1</span>] &amp;&amp; left &lt; right) left++;\\n    }\\n}\\n</code></pre>\\n<p>합계가 0인 숫자를 찾는 반복문은 매우 간단합니다. left ~ right까지 순회하면서 합이 0보다 크다면 right를 줄이고, 0보다 작다면 left를 증가시킵니다. 그리고 0인 숫자를 찾았다면 결과 배열에 삽입합니다.</p>\\n<p>위 행동은 입력된 숫자 배열을 정렬했기 때문에 가능한 행동입니다.</p>\\n<p><code>while (nums[left] == nums[left - 1] &amp;&amp; left &lt; right) left++;</code></p>\\n<p>위 반복문을 삽입한 이유도 위에서 설명한 nums[i] == nums[i - 1]일때 발생하는 중복과 동일하게 중복을 제거하기 위해 nums[left]가 nums[left - 1]와 다른 값이 나올때 까지 left를 증가시킵니다.</p>\\n<p>이해가 잘 되지 않는다면 <code>[0, 0, 0, 0]</code>의 입력값에 대해서 테스트해보시면 이해가 충분히 될 수 있을것 같습니다.</p>\\n<h4 id=\\"제출-결과-1\\">제출 결과</h4>\\n<p><img src=\\"/assets/images/leet_code/15/result_3.png\\" alt=\\"Solution 2 result\\"></p>\\n<p>모든 숫자를 순회하므로 첫 반복문은 O(n)입니다.</p>\\n<p>그리고 내부의 while(left &lt; right) 반복문은 O(logn)이 됩니다. 때문에 O(nlogn)의 시간 복잡도가 계산될 것 같습니다.</p>\\n<details>\\n<summary>코드 전문</summary>\\n\\n<pre><code class=\\"language-c++\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Solution</span> \\n{\\n<span class=\\"hljs-keyword\\">public</span>:\\n    vector&lt;vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&gt; <span class=\\"hljs-built_in\\">threeSum</span>(vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&amp; nums) \\n    {\\n        vector&lt;vector&lt;<span class=\\"hljs-type\\">int</span>&gt;&gt; result;\\n\\n        <span class=\\"hljs-built_in\\">sort</span>(nums.<span class=\\"hljs-built_in\\">begin</span>(), nums.<span class=\\"hljs-built_in\\">end</span>());\\n\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; nums.<span class=\\"hljs-built_in\\">size</span>(); i++)\\n        {\\n            <span class=\\"hljs-keyword\\">if</span> (i &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\\"hljs-number\\">1</span>]) <span class=\\"hljs-keyword\\">continue</span>;\\n\\n            <span class=\\"hljs-type\\">int</span> left = i + <span class=\\"hljs-number\\">1</span>;\\n            <span class=\\"hljs-type\\">int</span> right = nums.<span class=\\"hljs-built_in\\">size</span>() - <span class=\\"hljs-number\\">1</span>;\\n\\n            <span class=\\"hljs-keyword\\">while</span> (left &lt; right)\\n            {\\n                <span class=\\"hljs-type\\">int</span> sum = nums[i] + nums[left] + nums[right];\\n\\n                <span class=\\"hljs-keyword\\">if</span> (sum &gt; <span class=\\"hljs-number\\">0</span>) right--;\\n                <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (sum &lt; <span class=\\"hljs-number\\">0</span>) left++;\\n                <span class=\\"hljs-keyword\\">else</span>\\n                {\\n                    result.<span class=\\"hljs-built_in\\">push_back</span>(vector&lt;<span class=\\"hljs-type\\">int</span>&gt;{nums[i], nums[left], nums[right]});\\n\\n                    left++;\\n                    <span class=\\"hljs-keyword\\">while</span> (nums[left] == nums[left - <span class=\\"hljs-number\\">1</span>] &amp;&amp; left &lt; right) left++;\\n                }\\n            }\\n        }\\n\\n        <span class=\\"hljs-keyword\\">return</span> result;\\n    }\\n};\\n</code></pre>\\n</details>\\n"}')}}]);